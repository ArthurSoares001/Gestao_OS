unit Biblioteca;

interface
                                                                                                                                                                                     
uses Forms, StdCtrls, Mask, ExtCtrls, Grids, WinTypes, SysUtils, RxToolEdit, Menus,
     RxCurrEdit, Constantes, Math, Classes, Winsock, OrComboBox, DateUtils, XMLIntf,
     OrObject, RXSpin, Windows, Messages, Variants, TrocarImpressoraPadrao, CEST,
     Graphics, Controls, Dialogs, ComCtrls, Buttons, FMTBcd, DB, DBClient, SqlExpr,
     RDPrint, OrEdit, OrStringGrid, ACBrValidador;

type
   TRoundToRange = -37..37;
   Erro = class(Exception);
   ETipoMovimentoInvalido = class(Exception);


   function  proximaDezena(numero: integer): integer;
   procedure limparInterface(form: TForm);
   procedure arredondarInterface(form: TForm);
   procedure limparInterfaceFrame(frame: TFrame);
   procedure limparInterfaceComponent(component: TComponent);
   procedure arredondarInterfaceComponent(component: TComponent);
   procedure organizarTabOrder(form: TForm);
   procedure verHabilitaCombo(combo: TComboBox);
   //function NewWindowProc(WindowHandle : hWnd; TheMessage: LongInt; ParamW: LongInt; ParamL: LongInt) : LongInt stdcall;
   function GetBuildInfo:string;
   // Funçao que retorna uma cadeia de caracteres somente numeros
   function strNumeros(pCadeia: string): string;
   // Funçao que retorna uma cadeia de caracteres somente letras
   function strLetras(pCadeia: string): string;
   // Funçao que formata Valor
   function StrToValor(valor: string): extended;
   // Funçao que retorna uma cadeia de caracteres com zeros
   function StrZero(valor, qtd_zeros: integer; separadorMilhar: string = ''): string;
   // Funcao que transforma uma Data DDMMYYYY para data
   function StrToData(cadeia: string): TDateTime;
   // Funcao que transforma uma Data DDMMYYYY para data
   function StrToData2(cadeia: string): TDateTime;
   // Funcao que transforma uma Data DDMMYYYY para data
   function StrToData3(cadeia: string): TDateTime;

   // Funçao que retorna uma cadeia de caracteres preenchida com o caracter enviado a direita
   function PadR(cadeia, caracter: string; qtd: integer): string;
   // Funçao que retorna uma cadeia de caracteres preenchida com o caracter enviado a esquerda
   function PadL(cadeia, caracter: string; qtd: integer): string;
   // Funçao que retorna uma cadeia de caracteres preenchida com o caracter enviado metade a esquerda e metade a direita
   function PadC(cadeia, caracter: string; qtd: integer): string;
   // Funcao que retorna 0 quando falso e 1 quando verdadeiro
   function booleanToInteger(variavel: boolean): integer;
   function booleanToString(variavel: boolean): String;
   // Funcao que retorna false quando 0 e true quando 1
   function IntegerToBoolean(variavel: integer): boolean;
   function StringToBoolean(variavel: String): boolean;
   // Funcao que retorna o arquivo INI
   function arqIni: string;
   // Funcao que retorna o diretorio temp do windows
   function GetWindowsTemp: string;
   // Funcao que retorna o diretorio da aplicacao
   function GetApplicationPath: string;
   //Função que retonar a letra digitada em maiúscula
   function UCase(letra: char): char;
   //Função que quebra o texto em varias linhas
   function quebraTexto(texto: string; tamLinha: integer): arrString;
   // Função que retorna um valor por extenso
   function ValorPorExtenso(valor: extended): string;
   // Função que retorna um numero por extenso
   function NumeroPorExtenso(valor: extended): string;
   // Procedimento que grava um arquivo XML
   procedure SaveXMLDocument(nameXML, xml: string);
   //Função que monta uma arquivo XML
   function  MountFileXML(path: string): string;
   // Função ChaveInicioCombo
   function ChaveEsquerda(texto: string): string;
   // Função ChaveInicioCombo
   function ChaveDireita(texto: string): string;
   // Função RemoveCaracterEspecial
   function RemoverCaracterEspecial(texto: string): string;
   //Função que arredonda valor passando a quantidade de casas decimais
   function Arredondar(Value: Extended; Decimals: integer = 2): Extended;
   //Funçao para apagar diretorios
   function delTree(dirName : string; NaoPassarPelaLixeira: boolean): boolean;
   // Funcao que retorna o tamanho do arquivo;
   function TamArquivo(arquivo: string): integer;
   //Funcao que retorno o conteudo do arquivo
   function ConteudoArquivoTxt(arquivo: string): WideString;
   // Funcao que retorna o dir acima
   function DirAcima(arvore: string): string;
   function ExtDir(arquivo: string): string;
   function ProxNo(arvore, dir: string): string;
   // Funcao que recebe uma String e retorna um CRC Decimal
   function CalculaCRC(linha: string): LongWord;
   // procedure para esvaziar a lixeira do windows
   procedure EsvaziarLixeira;
   // StringGridToString
   function stringGridToString(stringGrid: TStringGrid; separador: string): string;
   // StringToStringGrid
   procedure StringToStringGrid(stringGrid: TStringGrid; cadeia, separador: string);
   //Retorna o nome do mes por extenso
   function NomedoMes(dData:TDatetime):string;
   //Retorna o numero do mes por extenso
   function NumerodoMes(dData:TDatetime):string;
   //Retorna o numero do dia por extenso
   function NomedoDia(dData:TDatetime):string;
   // funcao para validar email
   function ValidarEmail(const EMailIn: PChar): Boolean;
   // funcao para retornar o caminho da aplicacao
   function ExtrairCaminhoAplicacao: String;
   // Mudar a impressora padrao
   function SetarImpressoraPadrao: boolean;
   // Funcao palavra da tabela
   function palavraTabela(quantidade: double; palavra: string): string;
   //formatar RG
   function formatarRG(numero: String): String;
   //formatar CEP
   function formatarCEP(numero: String): String;
   //formatar CPF
   function formatarCPF(numero: String): String;
   //formatar CNPJ
   function formatarCNPJ(numero: String): String;
   // Formatar telefone
   function formatarTelefone(numero: string): string;
   // Recuperar o nome da maquina
   function NomeComputador: String;
   //NF-E. Tratar retorno WS
   function TRATAR_RET_WS(cStat: integer): String;
   //CT-E. Tratar retorno WS
   function TRATAR_RET_WS_CTE(cStat: integer): String;
   //Recuperar IP
   function GetIP: String;
   //Abre um programa externo                                           
   procedure AbrirPrograma(caminho: string);
   //Fechar programa externo
   procedure FecharPrograma(caminho: string);
   //Diz se o CFOP é de entrada ou de saída
   function EhCFOPEntrada(cfop: string): boolean;
   //Tipo pontos
   function TiraPontos(Str: string): string;
   //espacamento
   function Space(Tamanho: Integer): string;
   //remove zero a esquerda
   function RemoveZerosEsquerda(S: string): string;
   //remove zero a direita
   function RemoveZerosDireita(S: string): string;
   //Retorna o Ultimo dia do mes de uma determinada data
   function UltDiaDoMes(Data: TDateTime): Word;
   //Verificar se um diretorio existe
   function DiretorioExiste(Dir: string): boolean;
   //Valida estado
   Function ValidaEstado(Dado : string) : boolean;
   //Valida CST ICMS
   Function ValidaCSTICMS(Dado : string) : boolean;
   //Aprovar CST ICMS
   Function AprovarCST(CST: String; opatantePeloSimples: boolean): Boolean;
   //Aprovar Aliquota X CST ICMS
   Function AprovarAliquotaCSTICMS(Aliquota: Currency; CST: String): Boolean;
   //Apaga arquivos usando mascaras tipo: c:\Temp\*.zip, c:\Temp\*.* Obs: Requer o Path dos arquivos a serem deletados
   Procedure ZapFiles(vMasc:String);
   //esconde ou exibe a barra do Windows
   Procedure SetTaskBar(Visible: Boolean);
   function MD5File(const fileName: string): string;
   function MD5String(const texto: string): string;
   //enviar email para
   function EnviarEmail(porta, host, usuario, senha, cabecalho, corpo, emailRemetente, nomeRemetente, emailDestinatario, nomeDestinatario, anexo, chaveAcesso, arquivoPDF: string): boolean;
   //enviar email usando ACBr
   function EnviarEmailACBr(porta, host, usuario, senha, assunto, emailRemetente, nomeRemetente, emailDestinatario, nomeDestinatario, anexo: string; corpo: TStringList): boolean;
   //enviar email ISMotors
   function EnviarEmailISMotors(cabecalho, corpo, emailRemetente, nomeRemetente, emailDestinatario, nomeDestinatario, anexo: string): boolean;
   //Atualizar combo mesmo que  seja preenchido manual
   procedure CheckEnableCombo(out combo: TOrComboBox);
   //Calcular custo medio entre dois valores
   function CalcularCustoMedio(valorAnterior, valor, desconto, frete: currency; qtdAnterior, qtd: double; QtdCasasDecimais: integer): currency;
   //Retorna a posicao da string na lista
   function CharToPos(chave: string; stringList: TStrings): integer;
   //Retorna string na lista pela posicao
   function PosToChar(pos: integer; stringList: TStrings): string;
   //Desativa o botao sair do form
   procedure DesativarBotaoSairDoForm(form: TForm);
   //Verificar se o CFOP é de devolução
   function VerificarCFOPDevolucaoCompra(CFOP: integer): boolean;
   //Verificar se o CFOP é de venda
   function VerificarCFOPVenda(CFOP: integer): boolean;
   //Verificar se o CFOP é de remessa de deposito
   function VerificarCFOPRemessaDeposito(CFOP: integer): boolean;
   //Verificar se o CFOP é de transferencia
   function VerificarCFOPTransferencia(CFOP: integer): boolean;
   //Verificar se o CFOP é de combustivel
   function VerificarCFOPCombustivel(CFOP: integer): boolean;
   //Verificar se o CFOP Conserto ou reparo
   function VerificarCFOPConsertoReparo(CFOP: integer): boolean;
   //Verificar se o CFOP baixa de estoque
   function VerificarCFOPBaixaEstoque(CFOP: integer): boolean;
   //Verificar se o diretorio esta com o ultimo caracter e adiciona
   function VerificarAddUltimoDiretorio(diretorio, ultimoCaracter: String): String;
   //Transformar valor em porcentagem
   function TransformarValorEmPorcentagem(valorTotal, valorItem: currency): double;
   //Verificar se o numero esta na Grid
   function NumeroConstaNaGrid(grid: TStringGrid; numero: string; coluna: integer = 0): boolean;
   //Verificar se uma id ou chave esta na Grid
   function ChaveContaNaGrid(grid: TStringGrid; chave: string; coluna: integer = 0): boolean;
   //Verificar se a string esta na Grid
   function StringConstaNaGrid(grid: TStringGrid; chave: string; col: integer): integer;
   //Pega a conteudo da primeira coluna da grid
   function  extrairChavePosGrid(grid: TStringGrid; col: integer): String;
   //Validar codigo de barra
   function ValidarCodigoBarra(vEan: String): Boolean;
   //Habilitar ou Desabilitar checkBoxs
   procedure HabilitarDesabilitarCheckBoxs(component: TComponent; habilitar: boolean);
   //Truncar casas ECF
   function TruncTo(const valor: Double; decimal: integer): Double;
   //Truncar casas NFCe
   function TruncaValor(pValor:Double; Decimais:Integer):Currency;
   //Diferneca entre duas datas
   Function calculaTempo(data1 : TDateTime; data2 : TDateTime) : String;
   //Diferneca entre meses
   Function calculaTempoMes(data1 : TDateTime; data2 : TDateTime) : Integer;
   //Formatar agencia conta de banco
   function formatarAgenciaConta(texto: string): String;
   //Validar codigo GTIN
   function ValidarGTIN(GTIN: String): Boolean;
   //Função para criptografar e descriptografar string's
   function Codifica(Action, Src: String): String;
   //Formatar float para PAF
   function FormataFloat(Tipo:String; Valor: Extended): string;
   //Formatar placa de veiculo
   function formatarPlacaVeiculo(placa: String): String;
   //Função que remove espaço em branco no inicio e fim
   function RemoveEspacoInicioFimTexto(texto: String): String;
   //Função que remove mensagem do PALM
   function RemoveMensagemPalm(texto: String): String;
   //Função que remove letras no inicio e fim
   function RemoveLetrasInicioFimTexto(texto: String): String;
   //Pegar e tratar valor de TAG
   function TagToInt(No: IXMLNode; nome: String): integer;
   function TagToStr(No: IXMLNode; nome: String): String;
   function TagToCurr(No: IXMLNode; nome: String): extended;
   function TagToDate(No: IXMLNode; nome: String): TDateTime;
   function FormatarCurrency(valor: currency; qtdCasas: integer): String;
   //Salvar arquivo txt
   function SaveTXTDocument(nameArq, texto: string): String;
   //Gravar log de sistema
   procedure AtualizarLog(nameArq, texto: string);
   //Montar arquivo BAT
   procedure MontarArqBAT(Arquivo, comando: string);
   //Excutar arquivo DOS
   function ExecutarArqBAT(comando: string): boolean;
   //Funcao que retorna o dia da semana
   function DiaSemana(Data:TDateTime): String;
   //Funcao que retorna a quantidade de dias uteis entre duas datas
   function DiasUteis(de, ate: TDateTime): integer;
   //Converter data
   function ConverterData(data: String): TDateTime;
   //Formatar chave de acesso nfe
   function FormatarChaveAcesso(chave: String): String;
   //Verificar se um IP da rede esta acessivel
   function PingIp(host: String; timeOut: integer = 500): Boolean;

   //Verificando se a URL esta on-line
   function ServerOnline(URL: String): boolean;
   //Pega o IP de um host
   Function GetIPHost(WebHostName:string):string;
   //Pega o host de um IP
   Function GetHostNameIP(strIPAddress : String) : String;

   //Conversores DiaSemana
   function IntegerToDiaSemana(dia: integer): TDiaSemana;
   function DiaSemanaToInteger(dia: TDiaSemana): integer;
   function DiaSemanaToStr(dia: TDiaSemana): String;

   //Converter data-Hora
   //A String deve estar no formato: DD/MM/AA HH:MM:SS.
   function ConverterDataHora(data: String; hora: String): TDateTime;
   function MontarDataHora(data: String; hora: String; HorasASomar: Double): TDateTime;

   //Conversores StatusCT-e
   function StrToStatusCTe(status: String): TStatusCTe;
   function StatusCTeToStr(status: TStatusCTe): String;

   //Conversores StatusMDF-e
   function StrToStatusMDFe(status: String): TStatusMDFe;
   function StatusMDFeToStr(status: TStatusMDFe): String;

   //Conversores StatusDF-e
   function StrToStatusDFe(status: String): TStatusDFe;
   function StatusDFeToStr(status: TStatusDFe): String;

   //Conversores StatusGNRE
   function StrToStatusGNRE(status: String): TStatusGNRE;
   function StatusGNREToStr(status: TStatusGNRE): String;

   //Encontrar estado por código IBGE
   Function encontrarEstadoCodigoIBGE(Dado : Integer) : String;
   Function EstadoToCodigoIBGE(UF : String): integer;

   //Ativar quilhotina de impressora nao fiscal
   function ativarGuilhotina: String;

   //Ativar quilhotina de impressora nao fiscal
   function ativarGuilhotinaElginI9: String;

   //Ativar quilhotina de impressora nao fiscal
   function ativarGuilhotinaEpsonTmT20: String;

   function CortaPapel(const Epson:Boolean; Porta:String):Boolean;

   //Diz se o CFOP é de devoluçao saída
   function EhCFOPDevolucaoSaida(cfop: string): boolean;
   //Diz se o CFOP é de devoluçao entrada
   function EhCFOPDevolucaoEntrada(cfop: string): boolean;
   //Diz se o PIS-COFINS é de suspensão
   function EhSuspensaoPISCofins(piscofins: string): boolean;
   //Diz se o PIS-COFINS é de suspensão nas entradas
   function EhSuspensaoPISCofinsEntrada(piscofins: string): boolean;
   //Retorna o codigo do Estado pela Sigla
   function UFNFe(siglaEstado: string): integer;
   function ExtrairUFNFeChave(chave: string): integer;
   //Retorna os principais dados de uma NF-e
   procedure DesmembrarChaveNFe(chaveAcesso: string; out uf, cnpjEmitente, modelo, serie, numeroNFe: string);
   //Função que converte uma string em maiuscula.
   function ToUpper(Text: String): String;
   //Função que converte uma string em minuscula.
   function ToLower(Text: String): String;
   //Funcao que converte String em Sexo
   function StrToSexo(pos: String): TSexo;
   //Funcao que converte sexo em String
   function SexoToStr(tipoSexo: TSexo): String;
   //pedir senha do administrador
   {function PedirSenhaAdmin(permissaoDB: IPermissaoDB; configuracao: TORObject; moduloFinanceiro, moduloFaturamento, manipulandoParcela: boolean;
                            frmSenha: TFrmSenha; operacao: String; mensagemPersonalizada: String = MSG_SENHA_ADMINISTRADOR): boolean;

   //pedir senha do administrador com o usuario.
   function PedirSenhaAdminUsuario(permissaoDB: IPermissaoDB; configuracao: TORObject; moduloFinanceiro, moduloFaturamento: boolean;
                            frmSenha: TFrmSenha; operacao: String; mensagemPersonalizada: String = MSG_SENHA_ADMINISTRADOR): boolean;

   //pedir senha
   function PedirSenhaGeral(permissaoDB: IPermissaoDB; configuracao: TORObject; moduloFinanceiro, moduloFaturamento, manipulandoParcela: boolean;
                            frmSenha: TFrmSenha; operacao: String; mensagemPersonalizada: String = MSG_SENHA_ADMINISTRADOR): boolean;
}
   //Ler um texto de tras pra frente, usando o digito separado como indice de parada.
   function LerChaveTrasPraFrente(texto, digitoSeparador: string): string;

   //Tipo do documento fiscal referencia da NF
   function IntToTipoNFRef(pos: integer): TTipoNFRef;
   function TipoNFRefToInt(tipo: TTipoNFRef): Integer;

   //metodos usados na NFe e a formatacao de XMLs
   function FormatarValor(valor: double; qtdCasas: integer; arredondarValor: boolean = false): String;
   function FormatarValor2(valor: double; qtdCasas: integer): Double;
   function FormatarValorTruncando(valor: double; qtdCasas: integer; TruncarValor: boolean = false): String;
   function RoundNum(Valor:Extended;Decimais:Integer):Extended;
   function FormatarPorcentagem(porcentagem: double): String;
   function FormatarQuantidade(quantidade: double): String;
   function FormatarFloat(valor: currency; qtdCasas: integer): String;
   function FormatarValorLabel(valor: currency; qtdCasas: integer; labelx: String; monetario: boolean): String;

   //Funcao que formata a hora e o minuto.
   function FormatarStrHoraMInuto(text: String): String;

   //Funcao que remove os numeros de um texto.
   function RemoverNumero(texto: String): String;

   //Funcao que retorna os principais tipos de ocorrencia de boleto
   function TipoOcorrenciaBoletoToDescricao(codigo: integer): String;

   //Funcao que retorna o CEST com base no NCM e no CST da mercadoria
   ////(Código Especificador da Substituição Tributária)
   function CalcularCEST(NCM_SH, CST, CESTPROD: String): String;
   // monta o numero do telefone no formato (**)1234-1234
   Function OrganizaNumeroTelefone(numero: String) : String;

   //Funcao que verifica se a quantidade tem casas decimais.
   function DigitoQtd(qtd: Double): String;
   //Funcao que verifica se o valor tem casas decimais.
   function DigitoValor(Valor: Currency; monetario: boolean = false): String;

   //Funcao que resume a frase até a ocorrencia de números
   function ResumirDescricao(chave: String): String;
   //TipoDFe para Integer
   function TipoDFeToInt(tipo: TTipoDFe; tratarErro: boolean = false): integer;
   //Integer para TipoDFe
   function IntToTipoDFe(tipo: integer; tratarErro: boolean = false): TTipoDFe;
   //TipoDFe para String
   function TipoDFeToStr(tipo: TTipoDFe): String;
   //Iniciar conexao remota da tarefa agenda
   function iniciarConexaoRemotaTA: Boolean;
   //Copiar arquivo de uma pasta para outra
   procedure CopiarArquivoTXT(origem, destino: String);
   //BloquearInterface
   procedure bloquearTodaInterface(MainMenu: TMainMenu);
   //SetFocusPorId
   procedure setFocusPorId(form: TForm; id: integer);
   //Calcular desconto generico
   function CalcularDesconto(valorTabela, valorFinal: currency; emPercentual: boolean): Currency;
   //Calcular comssao generico
   function CalcularComissao(valorTotal, valorComissao: currency): Currency;
   //Procurar cidade no combo
   function procurarCidadeNome(combo: TOrComboBox; nome: string): integer;
   //Procurar parte de uma string
   function procurarSubString(texto: WideString; substring: String): integer;
   //Verificar campo so numeros
   function isNumeric(chave: String): boolean;
   //Trocar tab por Enter
   procedure tabEnter(form: TForm; Sender: TObject; var Key: Char);
   //Configuracao padrao de um form
   procedure organizarForm(form: TForm; xCaption: String);
   //ExportarGridparaExcel
   function exportarGridExcel(grid: TOrStringGrid; caminhoNomeArq: String; excessaoSilenciosa: boolean = false; visualizarExcel: boolean = true): boolean;
   //MemorizarAcaoDeBotao
   procedure memorizarBotao(leitura: boolean; out idBotao: integer);
   //TipoLancamentoToChar
   function TipoLancamentoToChar(tipo: TTipoLancamento): String;
   function CharToTipoLancamento(tipo: String): TTipoLancamento;
   //Calcular o tempo em horas ou Dias.
   function FormatHoras(time: double; havDay: boolean): string;
   //limpar Dados da Grid
   procedure limparDadosGrid(grid: TStringGrid);
   //CaracteristicaPetToINT
   function tipoCaracteristicaAnimalToInt(tipoCaracteristicaAnimal: TTipoCaracteristicaAnimal): integer;
   //INTtoCaracteristicaPet
   function IntToTipoCaracteristicaAnimal(tipo: integer): TTipoCaracteristicaAnimal;
   //LimparGrid
   procedure limparGrid(grid: TStringGrid);
   //Calcular margem de lucro
   function calcularMargemLucro(valorCusto, valorVenda: currency): currency;
   //GerarArquivoTXT
   procedure gerarArquivoTexto(diretorio, nomeArq: WideString; conteudo: WideString);
   //Input box com data
   function InputComData(var Data: string): boolean;
   //Converter uma string para StringList
   function StringToStringList(S : String; separador : char): TStringList;
   //Converter uma string para uma StringList de Instruções SQL
   function StringToSqlList(S : String): TStringList;
   //Verificar combo preenchido
   function VerificarComboPreenchido(cmb: TOrComboBox): boolean;
   //Ordenar StringGrid por coluna
   procedure OrdenarStringGrid(GenStrGrid: TStringGrid; ThatCol: Integer);
   //Calcular percentual sobre o valor total
   function CalcularPercentualTotal(valorTotal, valor: double): double;
   //Método para o sistema falar um texto.
   procedure Falar(texto: String);
   //Converter tipo PF ou PJ para String
   function tipoPessoaToString(pessoaFisica: boolean): String;
   // versões IE: 7, 8, 9 10 e 11
   Procedure SetIEEmulation(VersaoIE : Integer);
   //Validar codigo de barras GTIN
   function ValidaCodigoGTIN(Codigo:String): Boolean;
   function VerificarPrefixoEAN(Codigo:String): Boolean;
   //Cricar e exucurar comando
   function executarComando(comando: string): boolean;
   //Lancar lembrete na barra de tarefa
   procedure LancarLembreBarraTarefa;
   //Gravar e ler a posicao dos componentes com base na ultima utilizacao
   //MemorizarAcaoDeBotao
   procedure memorizarForm(leitura: boolean; form: TForm);
   procedure memorizarFrame(leitura: boolean; frame: TFrame);
   procedure memorizarPopUpMenu(leitura: boolean; form: TForm; popUpMenu: TPopupMenu);
   procedure memorizarCheckBox(leitura: boolean; form: TForm; apenas: String = NULL_STRING);
   //Status ticket
   function StatusTicketToChar(status: TStatusTicket): String;
   function CharToStatusTicket(status: String): TStatusTicket;
   function IntToStatusTicket(status: integer): TStatusTicket;
   //TipoMovimento
   function TipoMovimentoToint(tipo: TTipoMovimentoCaixa): integer;
   function TipoMovimentoToChar(tipo: TTipoMovimentoCaixa): String;
   function IntToTipoMovimento(tipo: integer): TTipoMovimentoCaixa;
   function CharToTipoMovimento(tipo: String): TTipoMovimentoCaixa;
   //Order String Grid por coluna
   procedure OrdenarGrid(grid: TStringGrid; coluna, tipoDados: integer; decrescente, total: boolean);
   procedure OrdenarGridMouseDown(grid: TStringGrid; Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
   procedure OrdenarGridMouseUp(grid: TStringGrid; Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
   //Apagar linha ou coluna de um StringGrid
   procedure ApagarLinhaStringGrid(RowNumber: Integer; Grid: TstringGrid);
   procedure MarcarLinhaStringGrid(RowNumber, ColNumber: Integer; Grid: TStringGrid; marcar: boolean);
   function  posItemNaGrid(grid: TStringGrid; chave: String; coluna: integer): integer;
   function PalavraConstaString(palavra, texto: String): boolean;
   //Gerar ID ou Chave Única
   function GerarChaveId: String;
   //Posicao de um caracter na String
   function PosCharString(caracter: String; texto: String): integer;
   function TratarStrExcel(valor: String): String;
   function VerTipoDadoStrExcel(valor: String): integer;
   //ACBR
   function enviarNotaEmail(porta, host, usuario, senha,
                            cabecalho, corpo, emailRemetente, nomeRemetente, emailDestinatario,
                            nomeDestinatario, anexo, chaveAcesso, arquivoPDF, fantasiaDestinatario, cidadeUF: string): boolean;
   //Validar Email
   function ValidaEMail(const EMailIn: PChar): Boolean;
   //Comparar se duas Strings sao iguais
   function ComparaStrings(st1, st2: String): boolean;
   //ConfigurarModeloImpressao
   procedure setModeloImpressoraReport(out report: TRDprint);
   //Tipo meta produto
   function tipoMetaToString(tipo: integer): String;
   //Tipo meta vendedor
   function tipoMetaVendedorToString(tipo: integer): String;
   //Formatar numero NFe
   function formatarNumeroNota(numero: double): string;
   //Tratar mes da String do periodo
   function  TratarMesPeriodo(periodo: String): String;
   //verificar se existe uma palavra no texto
   function ProcurarPalavraTexto(palavra, frase: String): boolean;
   //Listar subDiretorios de uma pasta raiz
   function ListarSubDiretorio(const sDirInicial: string): TStrings;
   // S para Sim e N para Nao
   function booleanToChar(variavel: boolean): String;

   function getIdComputador: String;
   procedure arredondarComponente(Componente: TWinControl; const Radius: SmallInt);
   function removerUltimoDigito(texto, digito: String): String;
   function VerificarItemNoCombo(combo: TOrComboBox; informacao: String): boolean;
   function StatusInterfaceToStr(StatusInterface: TStatusInterface): String;
   function Confirmacao(texto: string): boolean;

   function PosToTipoDespesaReceitaConta(pos: integer): TTipoDespesaReceitaConta;
   function TipoDespesaReceitaContaToPos(tipo: TTipoDespesaReceitaConta): integer;
   //
   procedure processando(form: TForm);
   procedure processoFinalizado(form: TForm);
   procedure AbreForm(aClasseForm: TComponentClass; aForm: TForm);
   //criptografia
   function AsciiToInt(Caracter: Char): Integer;
   function Criptografa(texto:string;chave:integer):String;
   function DesCriptografa(texto:string;chave:integer):String;

    //validador
   function validar(doc: String; tipo: integer): boolean;
   function ValidarTexto(texto: String): Boolean;
   function MostrarIdOuTexto(texto: String): Integer;
   function CalcularValorDesconto(valor, desconto: double):double;

  //arredondar
   procedure ArredondarMaioresView(Control: TWinControl);
   procedure ArredondarMenoresView(Control: TWinControl);
   procedure UsarArredondarView(Controle: TWinControl);

   procedure TratarCamposNegativos(Sender: TObject);

   //Mensagem Simples sem botao
   procedure MostrarMensagem(form: TForm; mensagem: String; tipo: TTipoMensagem; URL: String = '');
   function DiasEmAtraso(de, ate: TDateTime): Integer;

   procedure AtualizarImagem(const AImagemNome: string; spd: TSpeedButton);
   procedure AtualizarCoresReceberPagar(FImagemAtual: Integer; lblReceber, lblPagar: TLabel);
   function AlternarCorZebrada: TColor;
   procedure ResetarCorZebrada;
   function IdentificarTipo(const Valor: string): string;
   function MascararSenha(password: String): String;
   function TemDadosGrid(grid: TOrStringGrid): boolean;
   function BuscarCep(cep: String): boolean;
   function posItemCombo(combo: TOrComboBox; valor: String): integer;
   function ValidateCST(CSTCode: string): TCstType;
   function ValidarCST(CST : string): boolean;
   function ValidarPorcentagem(const Value: string): Boolean;

   function ArredondarPara4Casas(Valor: Double): Double;
   function TruncarPara2Casas(Valor: Double): Double;
   function formatarValorNfe(Valor: Double): Double;

   procedure PreencherComboMesesAnos(cmb: TComboBox);
  function QuebrarTexto(const Texto: string; TamanhoLinha: Integer): string;
  //pegar nome e versao do meu .exe
  function GetExeVersion: string;

  //Selecionar tipo do filtro mercadoria
  function escolherFiltroMercadoria(combo: TOrComboBox; descricao: String): integer;
implementation

uses ShellAPI, HttpApp, CRC32, shlobj, IniFiles, Printers, Registry,
     IdHashMessageDigest, IdHash, IdEMailAddress, IdSMTP, IdMessage,
     IdText, IdAttachmentFile, IdComponent, DataModule, OrMaskEdit,
     IdICMPClient, StrUtils, ComObj, OrDateEdit, OrCurrencyEdit,
     ACBrUtil, IntechStringGrid, ACBrMail, pcnConversaoNFe, OrMemo,
     pcnConversao, FormMensagem;

var
  LinhaImpar: Boolean = True; // Variável global para controlar a alternância

function proximaDezena(numero: integer): integer;
var
   dezena: integer;
begin
   dezena := trunc(numero/10) + 1;
   result := dezena * 10;
end;

procedure limparInterface(form: TForm);
var
   keyPreviewState: boolean;
begin
   with form do
   begin
      keyPreviewState := KeyPreview;
      if keyPreviewState then
         KeyPreview := false;

      limparInterfaceComponent(form);

      KeyPreview := keyPreviewState;
   end;
end;
procedure arredondarInterface(form: TForm);
var
   keyPreviewState: boolean;
begin
   keyPreviewState := form.KeyPreview;
   form.KeyPreview := false;

   arredondarInterfaceComponent(form);

   form.KeyPreview := keyPreviewState;
end;

procedure limparInterfaceFrame(frame: TFrame);
var
   keyPreviewState: boolean;
begin
   with frame do
      limparInterfaceComponent(frame);
end;

procedure limparInterfaceComponent(component: TComponent);
var
   i: integer;
begin
   with component do
   begin
      for i := 0 to (ComponentCount - 1) do
      begin
         if Components[i] is TEdit then
         begin
             TEdit(Components[i]).Text := NULL_STRING;
             TEdit(Components[i]).Ctl3D := false;
         end
         else if Components[i] is TMaskEdit then
         begin
            TMaskEdit(Components[i]).Text := NULL_STRING;
            TMaskEdit(Components[i]).Ctl3D := false;
         end
         else if Components[i] is TMemo then
         begin
            TMemo(Components[i]).Text := NULL_STRING;
            TMemo(Components[i]).Ctl3D := false;
         end
         else if Components[i] is TCurrencyEdit then
         begin
            TCurrencyEdit(Components[i]).Value := 0;
            TCurrencyEdit(Components[i]).Ctl3D := false;
         end
         else if Components[i] is TRadioGroup then
            TRadioGroup(Components[i]).ItemIndex := 0
         else if Components[i] is TCheckBox then
            TCheckBox(Components[i]).checked := false
         else if (Components[i] is TComboBox) then
         begin
            if (TComboBox(Components[i]).Enabled) and (TComboBox(Components[i]).Items.Count > 1) then
               TComboBox(Components[i]).ItemIndex := POS_NAO_ENCONTRADA;

            if (TComboBox(Components[i]).BevelKind <> bkFlat) then
            begin
               TComboBox(Components[i]).BevelKind := bkFlat;
               TComboBox(Components[i]).Ctl3D := false;
            end;
         end
         else if Components[i] is TStringGrid then
         begin
            if TStringGrid(Components[i]).FixedRows = 0 then
            begin
               TStringGrid(Components[i]).RowCount := 1;
               TStringGrid(Components[i]).Rows[0].Clear;
            end
            else
            begin
               TStringGrid(Components[i]).RowCount := 2;
               TStringGrid(Components[i]).Rows[1].Clear;
            end;
         end
         else if Components[i] is TDateEdit then
         begin
            if TDateEdit(Components[i]).DefaultToday then
               TDateEdit(Components[i]).Date := now
            else
               TDateEdit(Components[i]).Clear;
            TDateEdit(Components[i]).Ctl3D := false;
         end
         else if Components[i] is TFilenameEdit then
         begin
            TFilenameEdit(Components[i]).Text := NULL_STRING;
            TFilenameEdit(Components[i]).Ctl3D := false;
         end
         else if Components[i] is TRxSpinEdit then
         begin
            TRxSpinEdit(Components[i]).Text := '0';
            TRxSpinEdit(Components[i]).Ctl3D := false;
         end
         else if Components[i] is TPageControl then
         begin
            (Components[i] As TPageControl).ActivePageIndex := 0;
            (Components[i] As TPageControl).Style := tsFlatButtons;
         end
         else if Components[i] is TDateTimePicker then
            (Components[i] As TDateTimePicker).DateTime := now
         else if Components[i] is TRadioButton then
            (Components[i] As TRadioButton).Checked := false
         else if Components[i] is TDirectoryEdit then
         begin
            TDirectoryEdit(Components[i]).Text := NULL_STRING;
            TDirectoryEdit(Components[i]).Ctl3D := false;
         end
         else if Components[i] is TPageControl then
         begin
            TPageControl(Components[i]).Style := tsFlatButtons;
         end;
      end;
   end;
end;

procedure arredondarInterfaceComponent(component: TComponent);
var
  i: integer;
begin
  for i := 0 to component.ComponentCount - 1 do
  begin
    if component.Components[i] is TWinControl then
    begin
      UsarArredondarView(TWinControl(component.Components[i]));
    end;
  end;
end;

procedure organizarTabOrder(form: TForm);
var
   i: integer;
begin
  { with form do
      for i := 0 to (ComponentCount - 1) do
        TabOrder := i;}
end;

procedure verHabilitaCombo(combo: TComboBox);
begin
   if combo.Items.Count = 1 then
   begin
      combo.ItemIndex := 0;
      combo.Enabled := false;
   end;
end;

function GetBuildInfo:string;
var
   VerInfoSize: DWORD;
   VerInfo: Pointer;
   VerValueSize: DWORD;
   VerValue: PVSFixedFileInfo;
   Dummy: DWORD;
   V1, V2, V3, V4: Word;
   prog: string;
begin
   prog := ParamStr(0);
   VerInfoSize := GetFileVersionInfoSize(PChar(prog), Dummy);
   GetMem(VerInfo, VerInfoSize);
   GetFileVersionInfo(PChar(prog), 0, VerInfoSize, VerInfo);
   VerQueryValue(VerInfo, '\', Pointer(VerValue), VerValueSize);
   with VerValue^ do
   begin
      V1 := dwFileVersionMS shr 16;
      V2 := dwFileVersionMS and $FFFF;
      V3 := dwFileVersionLS shr 16;
      V4 := dwFileVersionLS and $FFFF;
   end;
   FreeMem(VerInfo, VerInfoSize);
   result := IntToStr(v1) + '.' + IntToStr (v2) + '.' +
             IntToStr(v3) + '.' + IntToStr (v4);
end;

function strNumeros(pCadeia: string): string;
var
   i     : integer;
   cadeia: string;
begin
   cadeia := '';
   for i := 1 to Length(pCadeia) do
      if pCadeia[i] in ['0'..'9'] then
         cadeia := cadeia + pCadeia[i];
   result := cadeia;
end;

function strLetras(pCadeia: string): string;
var
   i: integer;
   cadeia: string;
begin
   cadeia := '';
   for i := 1 to Length(pCadeia) do
      if pCadeia[i] in ['A'..'z'] then
         cadeia := cadeia + pCadeia[i];
   result := cadeia;
end;


function StrToValor(valor: string): extended;
begin
   valor := StringReplace(valor, '%', '', [rfReplaceAll, rfIgnoreCase]);
   valor := StringReplace(valor, FormatSettings.CurrencyString, '', [rfReplaceAll, rfIgnoreCase]);
   valor := StringReplace(valor, FormatSettings.ThousandSeparator, '', [rfReplaceAll, rfIgnoreCase]);
   result := StrToFloat(Trim(valor));
end;

function StrZero(valor, qtd_zeros: integer; separadorMilhar: string = ''): string;
var
   i: integer;
   cadeia: string;
begin
   cadeia := IntToStr(valor);
   if Length(cadeia) <= qtd_zeros then
   begin
      for i := 1 to (qtd_zeros - Length(cadeia)) do
      begin
          if (separadorMilhar <> '') and (Length(StrNumeros(cadeia)) MOD 3 = 0) then
             cadeia := separadorMilhar + cadeia;
          cadeia := '0' + cadeia;
      end;
   end;

   result := cadeia;
end;

function StrToData(cadeia: string): TDateTime;
var
   dia, mes, ano: integer;
begin
   if Copy(cadeia, 2, 1) = '/' Then
      dia := StrToInt(Copy(cadeia, 1, 1))
   else
      dia := StrToInt(Copy(cadeia, 1, 2));

   if Copy(cadeia, 3, 1) = '/' Then
      mes := StrToInt(Copy(cadeia, 4, 1))
   else
      mes := StrToInt(Copy(cadeia, 3, 2));

   if Copy(cadeia, 5, 1) = '/' Then
      ano := StrToInt(Copy(cadeia, 6, 4))
   else
      ano := StrToInt(Copy(cadeia, 5, 4));

   result := EncodeDate(ano, mes, dia);
end;

function StrToData2(cadeia: string): TDateTime;
var
   dia, mes, ano: integer;
begin
   if cadeia <> '' Then
   begin
      if Copy(cadeia, 2, 1) = '/' Then
         dia := StrToInt(Copy(cadeia, 1, 2))
      else
         dia := StrToInt(Copy(cadeia, 1, 2));

      if Copy(cadeia, 3, 1) = '/' Then
         mes := StrToInt(Copy(cadeia, 4, 2))
      else
         mes := StrToInt(Copy(cadeia, 3, 2));

      if Copy(cadeia, 6, 1) = '/' Then
         ano := StrToInt(Copy(cadeia, 7, 4))
      else
         ano := StrToInt(Copy(cadeia, 6, 4));

      result := EncodeDate(ano, mes, dia);
   end;
end;

function StrToData3(cadeia: string): TDateTime;
var
   dia, mes, ano: integer;
begin
   if Copy(cadeia, 5, 1) = '-' Then
      ano := StrToInt(Copy(cadeia, 1, 4))
   else
      ano := StrToInt(Copy(cadeia, 1, 4));

   if Copy(cadeia, 8, 1) = '/' Then
      dia := StrToInt(Copy(cadeia, 9, 2))
   else
      dia := StrToInt(Copy(cadeia, 9, 2));

   if Copy(cadeia, 8, 1) = '/' Then
      mes := StrToInt(Copy(cadeia, 6, 2))
   else
      mes := StrToInt(Copy(cadeia, 6, 2));


   result := EncodeDate(ano, mes, dia);
end;

function PadR(cadeia, caracter: string; qtd: integer): string;
var
   i: integer;
begin
   for i := 1 to qtd - Length(cadeia) do
       cadeia := cadeia + caracter;

   result := cadeia;
end;

function PadL(cadeia, caracter: string; qtd: integer): string;
var
   i: integer;
begin
   for i := 1 to qtd - Length(cadeia) do
       cadeia := caracter + cadeia;

   result := cadeia;
end;

function PadC(cadeia, caracter: string; qtd: integer): string;
var
   i: integer;
   Direita: boolean;
begin
   Direita := True;
   for i := 1 to qtd - Length(cadeia) do
   begin
       if Direita then
          cadeia := caracter + cadeia
       else
          cadeia := cadeia + caracter;
       Direita := not Direita;
   end;

   result := cadeia;
end;

function booleanToInteger(variavel: boolean): integer;
begin
   if variavel then
      result := 1
   else
      result := 0;
end;

function booleanToString(variavel: boolean): String;
begin
   if variavel then
      result := 'Sim'
   else
      result := 'Não';
end;

function IntegerToBoolean(variavel: integer): boolean;
begin
   if variavel = 1 then
      result := true
   else
      result := false;
end;

function StringToBoolean(variavel: String): boolean;
begin
   if UpperCase(variavel) = 'SIM' then
      result := true
   else
      result := false;
end;

function arqIni: string;
begin
   result := ExtractFilePath(Application.ExeName) + '\' + ARQ_INI;
end;

function GetWindowsTemp: string;
var
  tempFolder: array[0..MAX_PATH] of Char;
begin
  GetTempPath(MAX_PATH, @tempFolder);
  result := StrPas(tempFolder);
end;

function GetApplicationPath: string;
begin
   result := ExtractFilePath(Application.ExeName);
end;

Function encontrarEstadoCodigoIBGE(Dado : Integer) : String;
begin
   case Dado of
      11 : Result := 'RO';
      12 : Result := 'AC';
      13 : Result := 'AM';
      14 : Result := 'RR';
      15 : Result := 'PA';
      16 : Result := 'AP';
      17 : Result := 'TO';
      21 : Result := 'MA';
      22 : Result := 'PI';
      23 : Result := 'CE';
      24 : Result := 'RN';
      25 : Result := 'PB';
      26 : Result := 'PE';
      27 : Result := 'AL';
      28 : Result := 'SE';
      29 : Result := 'BA';
      31 : Result := 'MG';
      32 : Result := 'ES';
      33 : Result := 'RJ';
      35 : Result := 'SP';
      41 : Result := 'PR';
      42 : Result := 'SC';
      43 : Result := 'RS';
      50 : Result := 'MS';
      51 : Result := 'MT';
      52 : Result := 'GO';
      53 : Result := 'DF';
   end;
end;

Function EstadoToCodigoIBGE(UF : String): integer;
begin
   if (UF = 'RO') then
      result := 11
   else if (UF = 'AC') then
      result := 12
   else if (UF = 'AM') then
      result := 13
   else if (UF = 'RR') then
      result := 14
   else if (UF = 'PA') then
      result := 15
   else if (UF = 'AP') then
      result := 16
   else if (UF = 'TO') then
      result := 17
   else if (UF = 'MA') then
      result := 21
   else if (UF = 'PI') then
      result := 22
   else if (UF = 'CE') then
      result := 23
   else if (UF = 'RN') then
      result := 24
   else if (UF = 'PB') then
      result := 25
   else if (UF = 'PE') then
      result := 26
   else if (UF = 'AL') then
      result := 27
   else if (UF = 'SE') then
      result := 28
   else if (UF = 'BA') then
      result := 29
   else if (UF = 'MG') then
      result := 31
   else if (UF = 'ES') then
      result := 32
   else if (UF = 'RJ') then
      result := 33
   else if (UF = 'SP') then
      result := 35
   else if (UF = 'PR') then
      result := 41
   else if (UF = 'SC') then
      result := 42
   else if (UF = 'RS') then
      result := 43
   else if (UF = 'MS') then
      result := 50
   else if (UF = 'MT') then
      result := 51
   else if (UF = 'GO') then
      result := 52
   else if (UF = 'DF') then
      result := 53;
end;

function UCase(letra: char): char;
begin
   case letra of
      'a'..'z': Dec(letra, 32);
      'ç': letra := 'Ç';
      'á': letra := 'Á';
      'à': letra := 'À';
      'ã': letra := 'Ã';
      'â': letra := 'Â';
      'ä': letra := 'Ä';
      'é': letra := 'É';
      'è': letra := 'È';
      'ê': letra := 'Ê';
      'ë': letra := 'Ë';
      'í': letra := 'Í';
      'ì': letra := 'Ì';
      'î': letra := 'Î';
      'ï': letra := 'Ï';
      'ó': letra := 'Ó';
      'ò': letra := 'Ò';
      'õ': letra := 'Õ';
      'ô': letra := 'Ô';
      'ö': letra := 'Ö';
      'ú': letra := 'Ú';
      'ù': letra := 'Ù';
      'û': letra := 'Û';
      'ü': letra := 'Ü';
   end;
   result := letra;
end;

function quebraTexto(texto: string; tamLinha: integer): arrString;
var
   quebrar: boolean;
   arrLinha: arrString;
   i, j, divisao: integer;
   linha, primeiro: string;
begin
   i := 1;
   setLength(arrLinha, 0);
   linha := WrapText(texto, #13#10, ['.', ' ', '-', #9], tamLinha);
   linha := StringReplace(linha, #13#10, #0, [rfReplaceAll, rfIgnoreCase]);
   while (Length(linha) > 0) and (i <= Length(linha)) do
   begin
      if linha[i] = #0 then
         quebrar := true
      else
      begin
         Inc(i);
         quebrar := i > Length(linha);
      end;

      if quebrar then
      begin
         primeiro := Trim(copy(linha, 1, i - 1));
         linha := copy(linha, i + 1, Length(linha));
         setLength(arrLinha, Length(arrLinha) + 1);
         arrLinha[Length(arrLinha) - 1] := copy(primeiro, 1, tamLinha);
         if length(primeiro) > tamLinha then
         begin
            divisao := length(primeiro) DIV tamLinha;
            if divisao > 1 then
            begin
               for j := 1 to divisao - 1 do
               begin
                  setLength(arrLinha, Length(arrLinha) + 1);
                  arrLinha[Length(arrLinha) - 1] := copy(primeiro, (j * tamLinha) + 1, tamLinha);
               end;
            end;
            if length(primeiro) MOD tamLinha > 0 then
            begin
               setLength(arrLinha, Length(arrLinha) + 1);
               arrLinha[Length(arrLinha) - 1] := copy(primeiro, (divisao * tamLinha) + 1, tamLinha);
            end
         end;
         i := 1;
      end;
   end;
   result := arrLinha;
end;

function ValorPorExtenso(valor: extended): string;
var
   i: integer;
   numero, numextenso: string;
   digito: array[1..12] of string;
   U, DD:array[1..9] of string;
   D, C:array[1..10] of string;
begin
   // Unidades
   U[1] := 'UM';     U[2] := 'DOIS';  U[3] := 'TRÊS';
   U[4] := 'QUATRO'; U[5] := 'CINCO'; U[6] := 'SEIS';
   U[7] := 'SETE';   U[8] := 'OITO';  U[9] := 'NOVE';

   // Dez
   DD[1] := 'ONZE';      DD[2] := 'DOZE';    DD[3] := 'TREZE';
   DD[4] := 'QUATORZE';  DD[5] := 'QUINZE';  DD[6] := 'DEZESSEIS';
   DD[7] := 'DEZESSETE'; DD[8] := 'DEZOITO'; DD[9] := 'DEZENOVE';

   // Dezenas
   D[1] := 'DEZ';      D[2] := 'VINTE';     D[3] := 'TRINTA';
   D[4] := 'QUARENTA'; D[5] := 'CINQÜENTA'; D[6] := 'SESSENTA';
   D[7] := 'SETENTA';  D[8] := 'OITENTA';   D[9] := 'NOVENTA';
   D[10] := 'CEM';

   // Centenas
   C[1] := 'CENTO';        C[2] := 'DUZENTOS';   C[3] := 'TREZENTOS';
   C[4] := 'QUATROCENTOS'; C[5] := 'QUINHENTOS'; C[6] := 'SEISCENTOS';
   C[7] := 'SETECENTOS';   C[8] := 'OITOCENTOS'; C[9] := 'NOVECENTOS';
   C[10] := 'MIL';

   numextenso := '';
   numero := Trim(Format('%12.2f', [valor]));
   numero := StringOfChar( '0', 12 - Length(numero)) + numero;
   for i := 1 to 12 do
      digito[i] := Copy(numero, i, 1);

   // Milhões
   if not (digito[1] = '0') then
   begin
      if (digito[1] = '1') and (digito[2] = '0') and (digito[3] = '0') then
         numextenso := numextenso + D[10]
      else
         numextenso := numextenso + C[StrToInt(digito[1])];

      if (not (digito[2] = '0')) or (not (digito[3] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if not (digito[2] = '0') then
   begin
      if (digito[2] = '1') and (not (digito[3] = '0')) then
         numextenso := numextenso + DD[StrToInt(digito[3])]
      else
         numextenso := numextenso + D[StrToInt(digito[2])];

      if (not (digito[2] = '1')) and (not (digito[3] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if (not (digito[2] = '1')) and (not (digito[3] = '0')) then
      numextenso := numextenso + U[StrToInt(digito[3])];

  if (not (digito[1] = '0')) or (not (digito[2] = '0')) or (not (digito[3] = '0')) then
  begin
      if (digito[1] = '0') and (digito[2] = '0') and (digito[3] = '1') then
         numextenso := numextenso + ' MILHÃO '
      else
         numextenso := numextenso + ' MILHÕES ';

      if (digito[4] = '0') and (digito[5] = '0') and (digito[6] = '0') and
         (digito[7] = '0') and (digito[8] = '0') and (digito[9] = '0') then
         numextenso := numextenso + 'DE'
      else
         if (digito[11] = '0') and (digito[12] = '0') then
            numextenso := numextenso + 'E ';
  end;

   // Milhares
   if not (digito[4] = '0') then
   begin
      if (digito[4] = '1') and (digito[5] = '0') and (digito[6] = '0') then
         numextenso := numextenso + D[10]
      else
         numextenso := numextenso + C[StrToInt(digito[4])];

      if (not (digito[5] = '0')) or (not (digito[6] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if not (digito[5] = '0') then
   begin
      if (digito[5] = '1') and (not (digito[6] = '0')) then
         numextenso := numextenso + DD[StrToInt(digito[6])]
      else
         numextenso := numextenso + D[StrToInt(digito[5])];

      if (not (digito[5] = '1')) and (not (digito[6] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if (not (digito[5] = '1')) and (not (digito[6] = '0')) then
      numextenso := numextenso + U[StrToInt(digito[6])];

  if (not (digito[4] = '0')) or (not (digito[5] = '0')) or (not (digito[6] = '0')) then
  begin
      numextenso := numextenso + ' MIL';
      if (not (digito[7] = '0')) or (not (digito[8] = '0')) or (not (digito[9] = '0')) then
      begin
         if (digito[11] = '0') and (digito[12] = '0') then
            numextenso := numextenso + ' E '
         else
            numextenso := numextenso + ' ';
      end;
  end;

   // Centenas
   if not (digito[7] = '0') then
   begin
      if (digito[7] = '1') and (digito[8] = '0') and (digito[9] = '0') then
         numextenso := numextenso + D[10]
      else
         numextenso := numextenso + C[StrToInt(digito[7])];

      if (not (digito[8] = '0')) or (not (digito[9] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if not (digito[8] = '0') then
   begin
      if (digito[8] = '1') and (not (digito[9] = '0')) then
         numextenso := numextenso + DD[StrToInt(digito[9])]
      else
         numextenso := numextenso + D[StrToInt(digito[8])];

      if (not (digito[8] = '1')) and (not (digito[9] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if (not (digito[8] = '1')) and (not (digito[9] = '0')) then
      numextenso := numextenso + U[StrToInt(digito[9])];

   if not ((digito[1] = '0') and (digito[2] = '0') and (digito[3] = '0') and
      (digito[4] = '0') and (digito[5] = '0') and (digito[6] = '0') and
      (digito[7] = '0') and (digito[8] = '0') and (digito[9] = '0')) then
      if (digito[7] = '0') and (digito[8] = '0') and (digito[9] = '1') then
         numextenso := numextenso + ' REAL'
      else
         numextenso := numextenso + ' REAIS';

   // Centavos
   if not ((digito[11] = '0') and (digito[12] = '0')) then
   begin
      if Trunc(valor) > 0 then
         numextenso := numextenso + ' E ';

      if not (digito[11] = '0') then
      begin
         if (digito[11] = '1') and (not (digito[12] = '0')) then
            numextenso := numextenso + DD[StrToInt(digito[12])]
         else
            numextenso := numextenso + D[StrToInt(digito[11])];

         if not (digito[12] = '0') then //(not (digito[11] = '1')) or (not (digito[12] = '0')) then
            numextenso := numextenso + ' E ';
      end;

      if (not (digito[11] = '1')) and (not (digito[12] = '0')) then
         numextenso := numextenso + U[StrToInt(digito[12])];

      if (digito[11] = '0') and (digito[12] = '1') then
         numextenso := numextenso + ' CENTAVO'
      else
         numextenso := numextenso + ' CENTAVOS';
   end;

   result := numextenso;
end;

// Função que retorna um numero por extenso
function NumeroPorExtenso(valor: extended): string;
var
   i: integer;
   numero, numextenso: string;
   digito: array[1..12] of string;
   U, DD:array[1..9] of string;
   D, C:array[1..10] of string;
begin
   // Unidades
   U[1] := 'UM';     U[2] := 'DOIS';  U[3] := 'TRÊS';
   U[4] := 'QUATRO'; U[5] := 'CINCO'; U[6] := 'SEIS';
   U[7] := 'SETE';   U[8] := 'OITO';  U[9] := 'NOVE';

   // Dez
   DD[1] := 'ONZE';      DD[2] := 'DOZE';    DD[3] := 'TREZE';
   DD[4] := 'QUATORZE';  DD[5] := 'QUINZE';  DD[6] := 'DEZESSEIS';
   DD[7] := 'DEZESSETE'; DD[8] := 'DEZOITO'; DD[9] := 'DEZENOVE';

   // Dezenas
   D[1] := 'DEZ';      D[2] := 'VINTE';     D[3] := 'TRINTA';
   D[4] := 'QUARENTA'; D[5] := 'CINQÜENTA'; D[6] := 'SESSENTA';
   D[7] := 'SETENTA';  D[8] := 'OITENTA';   D[9] := 'NOVENTA';
   D[10] := 'CEM';

   // Centenas
   C[1] := 'CENTO';        C[2] := 'DUZENTOS';   C[3] := 'TREZENTOS';
   C[4] := 'QUATROCENTOS'; C[5] := 'QUINHENTOS'; C[6] := 'SEISCENTOS';
   C[7] := 'SETECENTOS';   C[8] := 'OITOCENTOS'; C[9] := 'NOVECENTOS';
   C[10] := 'MIL';

   numextenso := '';
   numero := Trim(Format('%12.2f', [valor]));
   numero := StringOfChar( '0', 12 - Length(numero)) + numero;
   for i := 1 to 12 do
      digito[i] := Copy(numero, i, 1);

   // Milhões
   if not (digito[1] = '0') then
   begin
      if (digito[1] = '1') and (digito[2] = '0') and (digito[3] = '0') then
         numextenso := numextenso + D[10]
      else
         numextenso := numextenso + C[StrToInt(digito[1])];

      if (not (digito[2] = '0')) or (not (digito[3] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if not (digito[2] = '0') then
   begin
      if (digito[2] = '1') and (not (digito[3] = '0')) then
         numextenso := numextenso + DD[StrToInt(digito[3])]
      else
         numextenso := numextenso + D[StrToInt(digito[2])];

      if (not (digito[2] = '1')) and (not (digito[3] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if (not (digito[2] = '1')) and (not (digito[3] = '0')) then
      numextenso := numextenso + U[StrToInt(digito[3])];

  if (not (digito[1] = '0')) or (not (digito[2] = '0')) or (not (digito[3] = '0')) then
  begin
      if (digito[1] = '0') and (digito[2] = '0') and (digito[3] = '1') then
         numextenso := numextenso
      else
         numextenso := numextenso;

      if (digito[4] = '0') and (digito[5] = '0') and (digito[6] = '0') and
         (digito[7] = '0') and (digito[8] = '0') and (digito[9] = '0') then
         numextenso := numextenso + 'DE'
      else
         if (digito[11] = '0') and (digito[12] = '0') then
            numextenso := numextenso + 'E ';
  end;

   // Milhares
   if not (digito[4] = '0') then
   begin
      if (digito[4] = '1') and (digito[5] = '0') and (digito[6] = '0') then
         numextenso := numextenso + D[10]
      else
         numextenso := numextenso + C[StrToInt(digito[4])];

      if (not (digito[5] = '0')) or (not (digito[6] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if not (digito[5] = '0') then
   begin
      if (digito[5] = '1') and (not (digito[6] = '0')) then
         numextenso := numextenso + DD[StrToInt(digito[6])]
      else
         numextenso := numextenso + D[StrToInt(digito[5])];

      if (not (digito[5] = '1')) and (not (digito[6] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if (not (digito[5] = '1')) and (not (digito[6] = '0')) then
      numextenso := numextenso + U[StrToInt(digito[6])];

  if (not (digito[4] = '0')) or (not (digito[5] = '0')) or (not (digito[6] = '0')) then
  begin
      numextenso := numextenso;
      if (not (digito[7] = '0')) or (not (digito[8] = '0')) or (not (digito[9] = '0')) then
      begin
         if (digito[11] = '0') and (digito[12] = '0') then
            numextenso := numextenso + ' E '
         else
            numextenso := numextenso + ' ';
      end;
  end;

   // Centenas
   if not (digito[7] = '0') then
   begin
      if (digito[7] = '1') and (digito[8] = '0') and (digito[9] = '0') then
         numextenso := numextenso + D[10]
      else
         numextenso := numextenso + C[StrToInt(digito[7])];

      if (not (digito[8] = '0')) or (not (digito[9] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if not (digito[8] = '0') then
   begin
      if (digito[8] = '1') and (not (digito[9] = '0')) then
         numextenso := numextenso + DD[StrToInt(digito[9])]
      else
         numextenso := numextenso + D[StrToInt(digito[8])];

      if (not (digito[8] = '1')) and (not (digito[9] = '0')) then
         numextenso := numextenso + ' E ';
   end;

   if (not (digito[8] = '1')) and (not (digito[9] = '0')) then
      numextenso := numextenso + U[StrToInt(digito[9])];

   if not ((digito[1] = '0') and (digito[2] = '0') and (digito[3] = '0') and
      (digito[4] = '0') and (digito[5] = '0') and (digito[6] = '0') and
      (digito[7] = '0') and (digito[8] = '0') and (digito[9] = '0')) then
      if (digito[7] = '0') and (digito[8] = '0') and (digito[9] = '1') then
         numextenso := numextenso
      else
         numextenso := numextenso;

   // Centavos
   if not ((digito[11] = '0') and (digito[12] = '0')) then
   begin
      if Trunc(valor) > 0 then
         numextenso := numextenso + ' E ';

      if not (digito[11] = '0') then
      begin
         if (digito[11] = '1') and (not (digito[12] = '0')) then
            numextenso := numextenso + DD[StrToInt(digito[12])]
         else
            numextenso := numextenso + D[StrToInt(digito[11])];

         if not (digito[12] = '0') then //(not (digito[11] = '1')) or (not (digito[12] = '0')) then
            numextenso := numextenso + ' E ';
      end;

      if (not (digito[11] = '1')) and (not (digito[12] = '0')) then
         numextenso := numextenso + U[StrToInt(digito[12])];

      if (digito[11] = '0') and (digito[12] = '1') then
         numextenso := numextenso
      else
         numextenso := numextenso;
   end;

   result := numextenso;
end;

procedure SaveXMLDocument(nameXML, xml: string);
var
   arq: TextFile;
begin
   AssignFile(arq, ExtractFilePath(Application.ExeName) + '\' + nameXML);
   try
      Rewrite(arq);
      WriteLn(arq, xml);
   finally
      CloseFile(arq);
   end;
end;

function MountFileXML(path: string): string;
var
   arq: TextFile;
   linha: string;
begin
   result := NULL_STRING;
   AssignFile(arq, path);
   try
      Reset(arq);
      while not Eof(arq) do
      begin
         ReadLn(arq, linha);
         result := result + linha;
      end;
   finally
      CloseFile(arq);
   end;
end;

function ChaveEsquerda(texto: string): string;
begin
   result := Trim(Copy(texto, 1, Pos('-', texto) - 1));
end;

function ChaveDireita(texto: string): string;
begin
   result := Trim(Copy(texto, Pos('-', texto) +1, (length(texto) - Pos('-', texto) +1)));
end;

function LerChaveTrasPraFrente(texto, digitoSeparador: string): string;
var
   Chave: String;
   i,
   pos,
   cont : Integer;
   Achou: Boolean;
begin
   achou := False;
   Cont  := 0;
   chave := NULL_STRING;

   for i := length(texto) DownTo 1 do
   begin
      if not achou Then
      begin
         if Copy(texto, i, 1) <> digitoSeparador Then
         begin
            pos  := i;
            cont := cont + 1;
         end
         else
         begin
            achou := True;
            chave := Copy(Texto, pos, cont);
         end;
      end;
   end;

   result := Chave;
end;

function RemoverCaracterEspecial(texto: string): string;
begin
   texto := StringReplace(texto, 'Ã', 'A', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Á', 'A', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'À', 'A', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Â', 'A', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Ä', 'A', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'É', 'E', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Ê', 'E', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Í', 'I', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Ó', 'O', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Ô', 'O', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Õ', 'O', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Ö', 'O', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Ú', 'U', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Ý', 'Y', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Ç', 'C', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '´', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'µ', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '§', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '¨', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '·', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '£', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '¢', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Æ', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '«', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'ª', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '°', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, 'Ñ', '', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '&', 'E', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, ',', ' ', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '\', ' ', [rfReplaceAll, rfIgnoreCase]);
   texto := StringReplace(texto, '"', ' ', [rfReplaceAll, rfIgnoreCase]);
   result := texto;
end;

function arredondar(Value: Extended; Decimals: integer = 2): Extended;
var
  Factor, Fraction: Extended;
begin
  Factor := IntPower(10, Decimals);
  { A conversão para string e depois para float evita
    erros de arredondamentos indesejáveis. }
  Value    := StrToFloat(FloatToStr(Value * Factor));
  Result   := Int(Value);
  Fraction := Frac(Value);
  if Fraction >= 0.5 then
    Result := Result + 1
  else if Fraction <= -0.5 then
    Result := Result - 1;
  Result := Result / Factor;
end;

function delTree(dirName : string; NaoPassarPelaLixeira: boolean): boolean;
var
  SHFileOpStruct : TSHFileOpStruct;
  DirBuf : array [0..255] of char;

  SR: TSearchRec;
  I: Integer;
begin
   try
     if not NaoPassarPelaLixeira then
     begin
        Fillchar(SHFileOpStruct,Sizeof(SHFileOpStruct),0) ;
        FillChar(DirBuf, Sizeof(DirBuf), 0 );
        StrPCopy(DirBuf, DirName);
        with SHFileOpStruct do
        begin
           Wnd := 0;
           pFrom := @DirBuf;
           wFunc := FO_DELETE; // Apaga o arquivo ou os arquivos indicados
           fFlags := FOF_ALLOWUNDO; // O arquivo indicado é enviado para a lixeira
           fFlags := fFlags or FOF_NOCONFIRMATION; //O usuário nunca é perguntado para nada (Sim por default).
           fFlags := fFlags or FOF_SILENT; // Não mostra nenhuma mensagem de progresso
        end;
        Result := (SHFileOperation(SHFileOpStruct) = 0);
     end else
     begin // A PARTIR DESTE PONTO NAO ESTA FUNCIONANDO
        I := FindFirst(dirName + '\*.*', faAnyFile, SR);
        while I = 0 do
        begin
           DeleteFile(PChar(dirName + SR.Name));
           I := FindNext(SR);
        end;
        if not RemoveDir(dirName) then
           result := false;
     end;
   except
     Result := False;
   end;
end;

function TamArquivo(arquivo: string): Longint;
var
   arq: file of Byte;
begin
   result := NULL_INTEGER;
   if FileExists(arquivo) then
   begin
      AssignFile(arq, arquivo);
      Reset(arq);
      try
         result := FileSize(arq);
      finally
         CloseFile(arq);
      end;
   end;
end;

//Funcao que retorno o conteudo do arquivo
function ConteudoArquivoTxt(arquivo: string): WideString;
var
   arq: TextFile; { declarando a variável "arq" do tipo arquivo texto }
   linha: string;
begin
  AssignFile(arq, arquivo);
  {$I-}         // desativa a diretiva de Input
  Reset(arq);   // [ 3 ] Abre o arquivo texto para leitura
  {$I+}         // ativa a diretiva de Input

  result := '';

  if (IOResult <> 0) then
     result := 'Erro ao tentar abrir ao arquivo.'
  else
  begin
     while (not eof(arq)) do
     begin
        readln(arq, linha);
        result := result + linha;
     end;
     CloseFile(arq);
  end;
end;


function extDir(arquivo: string): string;
begin
   result := StringReplace(arquivo, ExtractFileName(UnixPathToDosPath(arquivo)), NULL_STRING, [rfReplaceAll, rfIgnoreCase]);
end;

function DirAcima(arvore: string): string;
var
   i, pos: integer;
begin
   pos := NULL_INTEGER;
   for i := 0 to Length(arvore) - 2 do
   begin
      if arvore[i] = '/' then
         pos := i;
   end;

   result := Copy(arvore, 1, pos);
end;

function NoAcima(arvore: string): string;
begin
   result := Copy(arvore, 1, Length(DirAcima(arvore)));
end;

function ProxNo(arvore, dir: string): string;
begin
   result := Copy(arvore, Length(dir) + 1, Length(arvore));
   result := Copy(result, 1, Pos('/', result));
end;

function CalculaCRC(linha: string): LongWord;
var
    CRC32:  DWORD;
begin
   CRC32 := $FFFFFFFF;
  if LENGTH(linha) > 0 then
     CalcCRC32 (Addr(linha[1]), LENGTH(linha), CRC32);
  CRC32 := NOT CRC32;
  result := CRC32;
end;

procedure EsvaziarLixeira;
Const
   SHERB_NOCONFIRMATION = $00000001 ;
   SHERB_NOPROGRESSUI = $00000002 ;
   SHERB_NOSOUND = $00000004 ;
Type
   TLimparLixeira = function (Wnd:HWND; pszRootPath : PChar; dwFlags : DWORD):HRESULT; stdcall;
Var
   LimparLixeira : TLimparLixeira;
   LibHandle : THandle;

Begin { Esvaziando a lixeira }
   LibHandle := LoadLibrary(PChar('Shell32.dll'));

   if LibHandle <> 0 then
      @LimparLixeira := GetProcAddress(LibHandle, 'SHEmptyRecycleBinA')
   else
      Exit;

   if @LimparLixeira <> nil then
      LimparLixeira (Application.Handle,nil,
      SHERB_NOCONFIRMATION or SHERB_NOPROGRESSUI or SHERB_NOSOUND);
   FreeLibrary(LibHandle);
   @LimparLixeira := nil;
end;

function StringGridToString(stringGrid: TStringGrid; separador: string): string;
var
   lin, col: integer;
begin
   result := NULL_STRING;
   for lin := 0 to stringGrid.RowCount - 1 do
   begin
//      result := result + IntToStr(lin) + separador;
      for col := 0 to stringGrid.ColCount - 1 do
      begin
         if stringGrid.Cells[col, lin] <> NULL_STRING then
            result := result + IntToStr(col) + '#' + IntToStr(lin) + separador + stringGrid.Cells[col, lin];
         if not ((lin = stringGrid.RowCount - 1) AND (col = stringGrid.ColCount - 1)) AND
               (stringGrid.Cells[col, lin] <> NULL_STRING) then
            result := result + separador;
      end;
   end;
end;

procedure StringToStringGrid(stringGrid: TStringGrid; cadeia, separador: string);
var
   linha: string;
   lin, col, i, rowCount, linhAnterior: integer;
begin
   lin := 0;
   col := 0;
   i := 0;
   rowCount := 0;
   if cadeia <> NULL_STRING then
   begin
      col := StrToInt(PChar(cadeia)[0]);
      lin := StrToInt(PChar(cadeia)[2]);
      i := 4;
      if stringGrid.FixedRows = 1 then
         rowCount := 2
      else
         rowCount := 1;
   end;

   linhAnterior := 0;

   while (i < Length(cadeia)) AND (cadeia <> NULL_STRING) do
   begin

      stringGrid.RowCount := rowCount; // + 1;

      while (PChar(cadeia)[i] <> separador) AND (i < Length(cadeia)) do
      begin
         linha := linha + PChar(cadeia)[i];
         Inc(i);
      end;

      stringGrid.Cells[col, lin] := linha;
      linha := NULL_STRING;

      if PChar(cadeia)[i] = separador then
      begin
         Inc(i);
         col := StrToInt(PChar(cadeia)[i]);
         Inc(i, 2);
         lin := StrToInt(PChar(cadeia)[i]);
         Inc(i, 2);
         if linhAnterior <> lin then
         begin
            Inc(rowCount);
            linhAnterior := lin;
         end;
      end;
   end;
end;

function NomedoMes(dData:TDatetime):string;
{Retorna o nome do mee, em extenso, de uma determinada data}
var
   nAno,nMes,nDia:word;

   NumeroMes : Integer;
   cMes      :array[1..12] of string;
begin
   {cMes[01] := '01 - Janeiro';
   cMes[02] := '02 - Fevereiro';
   cMes[03] := '03 - Março';
   cMes[04] := '04 - Abril';
   cMes[05] := '05 - Maio';
   cMes[06] := '06 - Junho';
   cMes[07] := '07 - Julho';
   cMes[08] := '08 - Agosto';
   cMes[09] := '09 - Setembro';
   cMes[10] := '10 - Outubro';
   cMes[11] := '11 - Novembro';
   cMes[12] := '12 - Dezembro';}

   cMes[01] := 'Janeiro';
   cMes[02] := 'Fevereiro';
   cMes[03] := 'Março';
   cMes[04] := 'Abril';
   cMes[05] := 'Maio';
   cMes[06] := 'Junho';
   cMes[07] := 'Julho';
   cMes[08] := 'Agosto';
   cMes[09] := 'Setembro';
   cMes[10] := 'Outubro';
   cMes[11] := 'Novembro';
   cMes[12] := 'Dezembro';

   NumeroMes := StrToInt(FormatDateTime('mm', dData));
   nMes := NumeroMes;

   //decodedate(dData,nAno,nMes,nDia);

   if (nMes >= 1) and (nMes <= 13)then
      result := cMes[nMes]
   else
      result := NULL_STRING;
end;

function NumerodoMes(dData:TDatetime):string;
{Retorna o nome do mee, em extenso, de uma determinada data}
var
   nAno,nMes,nDia:word;
   cMes:array[1..12] of string;
begin
   {cMes[01] := '01 - Janeiro';
   cMes[02] := '02 - Fevereiro';
   cMes[03] := '03 - Março';
   cMes[04] := '04 - Abril';
   cMes[05] := '05 - Maio';
   cMes[06] := '06 - Junho';
   cMes[07] := '07 - Julho';
   cMes[08] := '08 - Agosto';
   cMes[09] := '09 - Setembro';
   cMes[10] := '10 - Outubro';
   cMes[11] := '11 - Novembro';
   cMes[12] := '12 - Dezembro';}

   cMes[01] := '01';
   cMes[02] := '02';
   cMes[03] := '03';
   cMes[04] := '04';
   cMes[05] := '05';
   cMes[06] := '06';
   cMes[07] := '07';
   cMes[08] := '08';
   cMes[09] := '09';
   cMes[10] := '10';
   cMes[11] := '11';
   cMes[12] := '12';

   decodedate(dData,nAno,nMes,nDia);
   if (nMes >= 1) and (nMes <= 13)then
      result := cMes[nMes]
   else
      result := NULL_STRING;
end;

function NomedoDia(dData:TDatetime):string;
var
   nAno,nMes,nDia:word;
   cDia:array[1..31] of string;
begin
   cDia[01] := '01';
   cDia[02] := '02';
   cDia[03] := '03';
   cDia[04] := '04';
   cDia[05] := '05';
   cDia[06] := '06';
   cDia[07] := '07';
   cDia[08] := '08';
   cDia[09] := '09';
   cDia[10] := '10';
   cDia[11] := '11';
   cDia[12] := '12';
   cDia[13] := '13';
   cDia[14] := '14';
   cDia[15] := '15';
   cDia[16] := '16';
   cDia[17] := '17';
   cDia[18] := '18';
   cDia[19] := '19';
   cDia[20] := '20';
   cDia[21] := '21';
   cDia[22] := '22';
   cDia[23] := '23';
   cDia[24] := '24';
   cDia[25] := '25';
   cDia[26] := '26';
   cDia[27] := '27';
   cDia[28] := '28';
   cDia[29] := '29';
   cDia[30] := '30';
   cDia[31] := '31';

   decodedate(dData,nAno,nMes,nDia);
   if (nDia >= 1) and (nDia <= 31) then
      result := cDia[nDia]
   else
      result := NULL_STRING;
end;

function ValidarEmail(const EMailIn: PChar): Boolean;
const
   CaraEsp: array[1..40] of string[1] =
   ( '!','#','$','%','¨','&','*',
   '(',')','+','=','§','¬','¢','¹','²',
   '³','£','´','`','ç','Ç',',',';',':',
   '<','>','~','^','?','/','\','|','[',']','{','}',
   'º','ª','°');
var
   i,cont : integer;
   EMail : ShortString;
begin
   EMail := EMailIn;
   Result := True;
   cont := 0;
   if EMail <> NULL_STRING then
      if (Pos('@', EMail)<>0) and (Pos('.', EMail)<>0) then // existe @ .
      begin
         if (Pos('@', EMail)=1) or (Pos('@', EMail)= Length(EMail)) or (Pos('.', EMail)=1) or (Pos('.', EMail)= Length(EMail)) or (Pos(' ', EMail)<>0) then
            Result := False
         else // @ seguido de . e vice-versa
         if (abs(Pos('@', EMail) - Pos('.', EMail)) = 1) then
            Result := False
         else
         begin
            for i := 1 to 40 do // se existe Caracter Especial
               if Pos(CaraEsp[i], EMail)<>0 then
               Result := False;
               for i := 1 to length(EMail) do
               begin // se existe apenas 1 @
                  if EMail[i] = '@' then
                     cont := cont + 1; // . seguidos de .
                  if (EMail[i] = '.') and (EMail[i+1] = '.') then
                     Result := false;
               end;
               // . no f, 2ou+ @, . no i, - no i, _ no i
               if (cont >=2) or ( EMail[length(EMail)]= '.' ) or ( EMail[1]= '.' ) or ( EMail[1]= '_' ) or ( EMail[1]= '-' ) then
                  Result := false;
               // @ seguido de COM e vice-versa
               if (abs(Pos('@', EMail) - Pos('com', EMail)) = 1) then
                  Result := False;
               // @ seguido de - e vice-versa
               if (abs(Pos('@', EMail) - Pos('-', EMail)) = 1) then
                  Result := False;
               // @ seguido de _ e vice-versa
               {if (abs(Pos('@', EMail) - Pos('_', EMail)) = 1) then
                  Result := False;}
         end;
      end else
         Result := False;
end;

function ExtrairCaminhoAplicacao: String;
begin
   result := ExtractFilePath(Application.ExeName);
end;

function SetarImpressoraPadrao: boolean;
var
   PrinterSetupDialog: TPrinterSetupDialog;
begin
   PrinterSetupDialog := TPrinterSetupDialog.Create(nil);
   result := PrinterSetupDialog.Execute;
   if result then
      TrocarImpressoraPadrao.trocaImpressoraPadrao(Printer.Printers[Printer.PrinterIndex]);
end;

{
var
   Device : array[0..cchDeviceName] of char;
   Driver : array[0..MAX_PATH] of char;
   DriverPort : string;
   Port : array[0..MAX_PATH] of char;
   hDMode : THandle;
   s : array[0..64] of char;
   WinIni : TIniFile;
   WinIniFileName : array[0..MAX_PATH] of char;
   PrinterSetupDialog: TPrinterSetupDialog;
begin
   try
      PrinterSetupDialog := TPrinterSetupDialog.Create(nil);
      result := PrinterSetupDialog.Execute;
      if result then
      begin
         Printer.GetPrinter(@Device, @Driver, @Port, hDMode);

         // For some reason "Driver" is never defined here by GetPrinter.
         // Let's get "Driver,Port" from the Win.INI file "Devices" section
         GetWindowsDirectory(WinIniFileName, SizeOf(WinIniFileName));
         StrCat(WinIniFileName, '\win.ini');
         WinIni := TIniFile.Create(WinIniFileName);

         try
            // Lookup Driver,Port in INI file "Devices" section
            DriverPort := WinIni.ReadString('devices', Device, '');

           // Update INI "Windows" section -- this is the Windows default printer
           WinIni.WriteString('windows', 'device', Device + ',' + DriverPort)
         finally
            WinIni.Free
         end; // try

         // Flush INI cache
         WritePrivateProfileString(NIL, NIL, NIL, WinIniFileName);

         // Broadcast system wide message about win.ini change
         {s := 'windows';
         SendMessage(HWND_BROADCAST, WM_WININICHANGE, 0, Cardinal(@s));}
{      end; // if PrinterSetupDialog.Execute
   except
      // para nao estourar o erro quando a impressora layser estiver em outra maquina
   end;
end; // SetDefaultPrinter
}

function palavraTabela(quantidade: double; palavra: string): string;
var
   i: integer;
   qtd, estoque: string;
begin
   estoque := '';
   if quantidade > 0 then
   begin
      qtd := IntToStr(TRUNC(quantidade));
      for i := 1 to length(qtd) do
         case qtd[i] of
            '0': estoque := estoque + palavra[1];
            '1': estoque := estoque + palavra[2];
            '2': estoque := estoque + palavra[3];
            '3': estoque := estoque + palavra[4];
            '4': estoque := estoque + palavra[5];
            '5': estoque := estoque + palavra[6];
            '6': estoque := estoque + palavra[7];
            '7': estoque := estoque + palavra[8];
            '8': estoque := estoque + palavra[9];
            '9': estoque := estoque + palavra[10];
         end;
      if length(estoque) < 5 then
         estoque := StringOfChar(palavra[1], 5 - length(estoque)) + estoque;
   end;
   result := estoque;
end;

function formatarRG(numero: String): String;
begin
   result  := NULL_STRING;
   numero  := strNumeros(Trim(numero));

   if length(numero) = 5 Then
      result := Copy(numero, 1, 2) + '.' + Copy(numero, 3, 3)
   else if length(numero) = 6 Then
      result := Copy(numero, 1, 3) + '.' + Copy(numero, 4, 3)
   else if length(numero) = 7 Then
      result := Copy(numero, 1, 1) + '.' + Copy(numero, 2, 3) + '.' + Copy(numero, 5, 3)
   else if length(numero) = 8 Then
      result := Copy(numero, 1, 2) + '.' + Copy(numero, 3, 3) + '.' + Copy(numero, 6, 3)
   else if length(numero) = 9 Then
      result := Copy(numero, 1, 3) + '.' + Copy(numero, 4, 3) + '.' + Copy(numero, 7, 3)
   else
      result := numero;
end;

function formatarCEP(numero: String): String;
begin
   result  := NULL_STRING;
   numero  := strNumeros(Trim(numero));

   result := Copy(numero, 1, 2) + '.' + Copy(numero, 3, 3) + '-' +
      Copy(numero, 6, 3);

end;

function formatarCPF(numero: String): String;
begin
   result  := NULL_STRING;
   numero  := strNumeros(Trim(numero));

   result := Copy(numero, 1, 3) + '.' + Copy(numero, 4, 3) + '.' +
      Copy(numero, 7, 3) + '-' + Copy(numero, 10, 2);
end;

function formatarCNPJ(numero: String): String;
begin
   result  := NULL_STRING;
   numero  := strNumeros(Trim(numero));

   result := Copy(numero, 1, 2) + '.' + Copy(numero, 3, 3) + '.' +
      Copy(numero, 6, 3) + '/' + Copy(numero, 9, 4) + '-' + Copy(numero, 13, 2);
end;


function formatarTelefone(numero: string): string;
var
   tamanho: integer;
   num, prefixo, ddd: string;
begin
   result  := NULL_STRING;
   numero  := strNumeros(Trim(numero));
   tamanho := Length(numero);

   if (numero = NULL_STRING) then
      result := NULL_STRING
   else if (tamanho >= 8) then
   begin
      num     := Copy(numero, tamanho -3, 4);

      if tamanho = 8 Then
         prefixo := Copy(numero, tamanho -8, 4)
      else if tamanho = 10 Then
         prefixo := Copy(numero, tamanho -7, 4)
      else
         prefixo := Copy(numero, tamanho -8, 5);

      if tamanho > 9 then
      begin
         if Copy(numero, 1, 1) <> '0' then
         begin
            if tamanho = 10 Then
               ddd := Copy(numero, tamanho -9, 2)
            else
               ddd := Copy(numero, tamanho -10, 2);
         end
         else
            ddd := Copy(numero, tamanho -10, 2);
      end
      else
         ddd := ' ';
      result := '(' + ddd + ') ' + prefixo + '-' + num;
   end
   else
      result := 'Número inválido';
end;

function formatarPlacaVeiculo(placa: String): String;
var
   tamanho: Integer;

   sufixo,
   prefixo: String;
begin
   result := NULL_STRING;
   tamanho := length(placa);
   if tamanho = 7 Then
   begin
      prefixo := copy(placa, 1, 3);
      sufixo  := copy(placa, 4, 4);

      result := prefixo + '-' + sufixo;
   end
   else
   begin
      if copy(placa, 3, 2) = 'KM' then
         result := placa
      else
         result := 'Placa inválida';
   end;
end;

function NomeComputador: String;
var
   registro : TRegistry;
begin
   registro := TRegistry.create;
   registro.RootKey := HKEY_LOCAL_MACHINE;
   registro.openkey('System\CurrentControlSet\Services\VXD\VNETSUP',false);
   result := registro.readstring('ComputerName');
   if result = NULL_STRING then
   begin
      registro.openkey('System\CurrentControlSet\Control\ComputerName\ComputerName',false);
      result := registro.readstring('ComputerName');
   end;
end;

function TRATAR_RET_WS(cStat: integer): String;
begin
   result := NULL_STRING;
   case cStat of
      //RESULTADO DO PROCESSAMENTO DA SOLICITAÇÃO
      100: result := 'Autorizado o uso da NF-e';
      101: result := 'Cancelamento de NF-e homologado';
      102: result := 'Inutilização de número homologado';
      103: result := 'Lote recebido com sucesso';
      104: result := 'Lote processado';
      105: result := 'Lote em processamento';
      106: result := 'Lote não localizado';
      107: result := 'Serviço em Operação';
      108: result := 'Serviço Paralisado Momentaneamente (curto prazo)';
      109: result := 'Serviço Paralisado sem Previsão';
      110: result := 'Uso Denegado';
      111: result := 'Consulta cadastro com uma ocorrência';
      112: result := 'Consulta cadastro com mais de uma ocorrência';
      124: result := 'DPEC recebido pelo Sistema de Contingência Eletrônica';
      125: result := 'DPEC localizado';
      126: result := 'Inexiste DPEC para o número de registro de DPEC informado';
      127: result := 'Inexiste DPEC para a chave de acesso da NF-e informada';
      135: result := 'Evento registrado e vinculado a NF-e (cancelamento de NF-e homologado)';
      155: result := 'Evento registrado e vinculado a NF-e fora do prazo(deve haver multa)';
      //MOTIVOS DE NÃO ATENDIMENTO DA SOLICITAÇÃO
      201: result := 'Rejeição: O numero máximo de numeração de NF-e a inutilizar ultrapassou o limite';
      202: result := 'Rejeição: Falha no reconhecimento da autoria ou integridade do arquivo digital';
      203: result := 'Rejeição: Emissor não habilitado para emissão da NF-e';
      204: result := 'Rejeição: Duplicidade de NF-e';
      205: result := 'Rejeição: NF-e está denegada na base de dados da SEFAZ';
      206: result := 'Rejeição: NF-e já está inutilizada na Base de dados da SEFAZ';
      207: result := 'Rejeição: CNPJ do emitente inválido';
      208: result := 'Rejeição: CNPJ do destinatário inválido';
      209: result := 'Rejeição: IE do emitente inválida';
      210: result := 'Rejeição: IE do destinatário inválida';
      211: result := 'Rejeição: IE do substituto inválida';
      212: result := 'Rejeição: Data de emissão NF-e posterior a data de recebimento';
      213: result := 'Rejeição: CNPJ-Base do Emitente difere do CNPJ-Base do Certificado Digital';
      214: result := 'Rejeição: Tamanho da mensagem excedeu o limite estabelecido';
      215: result := 'Rejeição: Falha no schema XML';
      216: result := 'Rejeição: Chave de Acesso difere da cadastrada';
      217: result := 'Rejeição: NF-e não consta na base de dados da SEFAZ';
      218: result := 'Rejeição: NF-e já esta cancelada na base de dados da SEFAZ';
      219: result := 'Rejeição: Circulação da NF-e verificada';
      220: result := 'Rejeição: NF-e autorizada há mais de 24 horas';
      221: result := 'Rejeição: Confirmado o recebimento da NF-e pelo destinatário';
      222: result := 'Rejeição: Protocolo de Autorização de Uso difere do cadastrado';
      223: result := 'Rejeição: CNPJ do transmissor do lote difere do CNPJ do transmissor da consulta';
      224: result := 'Rejeição: A faixa inicial é maior que a faixa final';
      225: result := 'Rejeição: Falha no Schema XML da NFe';
      226: result := 'Rejeição: Código da UF do Emitente diverge da UF autorizadora';
      227: result := 'Rejeição: Erro na Chave de Acesso - Campo ID';
      228: result := 'Rejeição: Data de Emissão muito atrasada';
      229: result := 'Rejeição: IE do emitente não informada';
      230: result := 'Rejeição: IE do emitente não cadastrada';
      231: result := 'Rejeição: IE do emitente não vinculada ao CNPJ';
      232: result := 'Rejeição: IE do destinatário não informada';
      233: result := 'Rejeição: IE do destinatário não cadastrada';
      234: result := 'Rejeição: IE do destinatário não vinculada ao CNPJ';
      235: result := 'Rejeição: Inscrição SUFRAMA inválida';
      236: result := 'Rejeição: Chave de Acesso com dígito verificador inválido';
      237: result := 'Rejeição: CPF do destinatário inválido';
      238: result := 'Rejeição: Cabeçalho - Versão do arquivo XML superior a Versão vigente';
      239: result := 'Rejeição: Cabeçalho - Versão do arquivo XML não suportada';
      240: result := 'Rejeição: Cancelamento/Inutilização - Irregularidade Fiscal do Emitente';
      241: result := 'Rejeição: Um número da faixa já foi utilizado';
      242: result := 'Rejeição: Cabeçalho - Falha no Schema XML';
      243: result := 'Rejeição: XML Mal Formado';
      244: result := 'Rejeição: CNPJ do Certificado Digital difere do CNPJ da Matriz e do CNPJ do Emitente';
      245: result := 'Rejeição: CNPJ Emitente não cadastrado';
      246: result := 'Rejeição: CNPJ Destinatário não cadastrado';
      247: result := 'Rejeição: Sigla da UF do Emitente diverge da UF autorizadora';
      248: result := 'Rejeição: UF do Recibo diverge da UF autorizadora';
      249: result := 'Rejeição: UF da Chave de Acesso diverge da UF autorizadora';
      250: result := 'Rejeição: UF diverge da UF autorizadora';
      251: result := 'Rejeição: UF/Município destinatário não pertence a SUFRAMA';
      252: result := 'Rejeição: Ambiente informado diverge do Ambiente de recebimento';
      253: result := 'Rejeição: Digito Verificador da chave de acesso composta inválida';
      254: result := 'Rejeição: NF-e referenciada não informada para NF-e complementar';
      255: result := 'Rejeição: Informada mais de uma NF-e referenciada para NF-e complementar';
      256: result := 'Rejeição: Uma NF-e da faixa já está inutilizada na Base de dados da SEFAZ';
      257: result := 'Rejeição: Solicitante não habilitado para emissão da NF-e';
      258: result := 'Rejeição: CNPJ da consulta inválido';
      259: result := 'Rejeição: CNPJ da consulta não cadastrado como contribuinte na UF';
      260: result := 'Rejeição: IE da consulta inválida';
      261: result := 'Rejeição: IE da consulta não cadastrada como contribuinte na UF';
      262: result := 'Rejeição: UF não fornece consulta por CPF';
      263: result := 'Rejeição: CPF da consulta inválido';
      264: result := 'Rejeição: CPF da consulta não cadastrado como contribuinte na UF';
      265: result := 'Rejeição: Sigla da UF da consulta difere da UF do Web Service';
      266: result := 'Rejeição: Série utilizada não permitida no Web Service';
      267: result := 'Rejeição: NF Complementar referencia uma NF-e inexistente';
      268: result := 'Rejeição: NF Complementar referencia uma outra NF-e Complementar';
      269: result := 'Rejeição: CNPJ Emitente da NF Complementar difere do CNPJ da NF Referenciada';
      270: result := 'Rejeição: Código Município do Fato Gerador: dígito inválido';
      271: result := 'Rejeição: Código Município do Fato Gerador: difere da UF do emitente';
      272: result := 'Rejeição: Código Município do Emitente: dígito inválido';
      273: result := 'Rejeição: Código Município do Emitente: difere da UF do emitente';
      274: result := 'Rejeição: Código Município do Destinatário: dígito inválido';
      275: result := 'Rejeição: Código Município do Destinatário: difere da UF do Destinatário';
      276: result := 'Rejeição: Código Município do Local de Retirada: dígito inválido';
      277: result := 'Rejeição: Código Município do Local de Retirada: difere da UF do Local de Retirada';
      278: result := 'Rejeição: Código Município do Local de Entrega: dígito inválido';
      279: result := 'Rejeição: Código Município do Local de Entrega: difere da UF do Local de Entrega';
      280: result := 'Rejeição: Certificado Transmissor inválido';
      281: result := 'Rejeição: Certificado Transmissor Data Validade';
      282: result := 'Rejeição: Certificado Transmissor sem CNPJ';
      283: result := 'Rejeição: Certificado Transmissor - erro Cadeia de Certificação';
      284: result := 'Rejeição: Certificado Transmissor revogado';
      285: result := 'Rejeição: Certificado Transmissor difere ICP-Brasil';
      286: result := 'Rejeição: Certificado Transmissor erro no acesso a LCR';
      287: result := 'Rejeição: Código Município do FG - ISSQN: dígito inválido';
      288: result := 'Rejeição: Código Município do FG - Transporte: dígito inválido';
      289: result := 'Rejeição: Código da UF informada diverge da UF solicitada';
      290: result := 'Rejeição: Certificado Assinatura inválido';
      291: result := 'Rejeição: Certificado Assinatura Data Validade';
      292: result := 'Rejeição: Certificado Assinatura sem CNPJ';
      293: result := 'Rejeição: Certificado Assinatura - erro Cadeia de Certificação';
      294: result := 'Rejeição: Certificado Assinatura revogado';
      295: result := 'Rejeição: Certificado Assinatura difere ICP-Brasil';
      296: result := 'Rejeição: Certificado Assinatura erro no acesso a LCR';
      297: result := 'Rejeição: Assinatura difere do calculado';
      298: result := 'Rejeição: Assinatura difere do padrão do Projeto';
      299: result := 'Rejeição: XML da área de cabeçalho com codificação diferente de UTF-8';
      401: result := 'Rejeição: CPF do remetente inválido';
      402: result := 'Rejeição: XML da área de dados com codificação diferente de UTF-8';
      403: result := 'Rejeição: O grupo de informações da NF-e avulsa é de uso exclusivo do Fisco';
      404: result := 'Rejeição: Uso de prefixo de namespace não permitido';
      405: result := 'Rejeição: Código do país do emitente: dígito inválido';
      406: result := 'Rejeição: Código do país do destinatário: dígito inválido';
      407: result := 'Rejeição: O CPF só pode ser informado no campo emitente para a NF-e avulsa';
      409: result := 'Rejeição: Elemento nfeCabecMsg inexistente no SOAP Header';
      412: result := 'Rejeição: Campo versaoDados inexistente no elemento nfeCabecMsg do SOAP Header';
      479: result := 'Rejeição: Emissor em situação irregular perante o fisco';
      480: result := 'Rejeição: CNPJ da Chave de acesso da NF-e informada diverge do CNPJ do emitente';
      481: result := 'Rejeição: UF da Chave de acesso diverge do código da UF informada';
      482: result := 'Rejeição: AA da Chave de acesso inválida';
      483: result := 'Rejeição: MM da chave de acesso inválido';
      484: result := 'Rejeição: DV da Chave de acesso inválida';
      485: result := 'Rejeição: Chave de acesso já existe no cadastro de DPEC';
      486: result := 'Rejeição: DPEC não localizada para o número de registro de DPEC informado';
      487: result := 'Rejeição: Nenhuma DPEC localizada para a chave de acesso informada';
      488: result := 'Rejeição: Requisitante de Consulta não tem o mesmo CNPJ base do emissor da DPEC';
      578: result := 'A data do evento não pode ser maior que a data do processamento';
      999: result := 'Rejeição: Erro não catalogado (informar a mensagem de erro capturado no tratamento da exceção)';

      501: result := 'Rejeição: Pedido de Cancelamento intempestivo' + #13#10 + '(NF-e autorizada a mais de 24 horas)';

      //MOTIVOS DE DENEGAÇÃO DE USO
      301: result := 'Uso Denegado : Irregularidade fiscal do emitente';
      302: result := 'Uso Denegado : Irregularidade fiscal do destinatário';
      //RETORNO DE ERROS DA DLL
      5001: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: o certificado cliente: 1.não é ICP-Brasil; 2.fora do prazo de validade; 3.revogado; 4.certificado cliente não confiável para o Web Service acessado, contatar a SEFAZ)';
      5002: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: a cadeia de certificação do Web Service acessado ou do certificado cliente inexistente no repositório de certificados do usuário corrente do Windows)';
      5003: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: serviço inexistente, verifique se o nome do serviço da url acessada está correto no arquivo ws2.xml)';
      5004: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: método não permitido)';
      5005: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: a url não encontrada, verifique se o nome do domínio da url acessada está correto no arquivo ws2.xml)';
      5006: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: Time-Out, o WS não respondeu a solicitação no tempo estabelecido: [{1:0}])';
      5007: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: mensagem maior que a permitida)';
      5008: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: Servidor com problemas)';
      5009: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: Serviço não implementado)';
      5010: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: Serviço temporariamente indisponível, servidor sem recursos para atender a solicitação)';
      5011: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: Causa provável da falha na conexão: Rede indisponível)';
      5012: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: Versão do SOAP não suportada';
      5013: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: Web Service não consumido, não houve nenhum retorno ou resposta)';
      5014: result := 'Erro: Falha na conexão: [{0:0}] (Causa provável: Web Service não consumido, falha desconhecida)';
      5015: result := 'Erro: Falha na conexão: Tempo limite de time-out alcançado [{0:0} ms] - [{1:0}]';
      5016: result := 'Erro: Falha na conexão: Falha da Biblioteca Criptografica: [{0:0}]';
      5017: result := 'Erro: Falha ao tratar o XML de retorno do WS: [{0:0}]';
      5101: result := 'Erro: A mensagem de retorno do WS não é um XML válido: [{0:0}]';
      5102: result := 'Erro: Tag cStat inexistente na mensagem de retorno [{0:0}]';
      5103: result := 'Erro: Tag xMotivo inexistente na mensagem de retorno [{0:0}]';
      5104: result := 'Erro: Tag [{0:0}] inexistente na mensagem de retorno [{1:0}]';
      5105: result := 'Erro: O WS não devolveu nenhum resultado';
      5201: result := 'Erro: O código do tipo de ambiente [{0:0}] informado diferente de 1 - produção e 2 - homologação';
      5202: result := 'Erro: A sigla da UF [{0:0}] informada é inválida';
      5203: result := 'Erro: Inexiste url para a UF [{0:0}] informada no ambiente [{1:0}] desejado, verifique se existe atualização do arquivo [{2:0}] disponível.';
      5204: result := 'Erro: Arquivo WS.XML com a URL do WS não localizado em {0:0}\NFe_Util\URL\{1:0}';
      5205: result := 'Erro: Ocorreu um erro inesperado no processamento da URL ({0:0}) : [{1:0}';
      5206: result := 'Erro: Ocorreu um erro de validação do XML ({0:0}) : [{1:0}]';
      5401: result := 'Foi selecionado um Certificado com o nome informado';
      5402: result := 'Foi Selecionado o certificado de [{0:0}] na caixa de diálogo de escolha do certificado digital';
      5403: result := 'Erro: Falha ao acessar certificado digital [{0:0}]';
      5404: result := 'Erro: Nenhum certificado digital selecionado';
      5405: result := 'Erro: Nenhum certificado válido foi encontrado com o nome [{0:0}] informado';
      6101: result := 'Erro: O parâmetro versao não foi informado';
      6102: result := 'Erro: O conteúdo do parâmetro sigla da UF: [{0:0}] é inválido';
      6103: result := 'Erro: O conteúdo do parâmetro versao informado é inválido: [{0:0}]';
      6110: result := 'Erro: O nome do titular do certificado deve ser informado';
      6123: result := 'Erro: O parâmetro tipoAmbiente deve ser informado';
      6124: result := 'Erro: O parâmetro tipoAmbiente [{0:0}] deve ser 1 ou 2';
      6141: result := 'Erro: O parâmetro siglaWS deve ser informado';
      7001: result := 'Erro: A licença não foi informada';
      7002: result := 'Erro: A licença informada: [{0:0}] tem tamanho:[{1:0}] diferente de 128';
      7003: result := 'Erro: A licença informada: [{0:0}] não pertence ao CNPJ:[{1:0}]';

      //DPEC
      5501: result := 'Mensagem XML é válida';
      5502: result := 'Erro: tipoXML [{0:0}] inválido (fora do intervalo [{1:0}]';
      5503: result := 'Erro: XML mal formado [{0:0}]';
      5504: result := 'Erro: Arquivo Schemal XML [{0:0}] não localizado na pasta [{1:0}].';
      5505: result := 'Erro: XML não atende a especificação do Schema XML';
      5506: result := 'Erro: A validação da NF-e sem assinatura causa um erro de falta de assinatura que pode ser desprezado[{0:0}]';
      5507: result := 'Erro: XML com caracteres de identificação de codificação UTF-8 (\x0239\x0187\x0191) no início do arquivo';
      5508: result := 'Erro: XML com caracteres de identificação de codificação UTF-16 (BE) (\x0254\x0255) no início do arquivo';
      5509: result := 'Erro: XML com caracteres de identificação de codificação UTF-16 (LE) (\x0255\x0254) no início do arquivo';
      5510: result := 'Erro: XML com caracteres de identificação de codificação UTF-32 (BE) (\x0000\x0000\x0254\x0255) no início do arquivo';
      5511: result := 'Erro: XML com caracteres de identificação de codificação UTF-32 (LE) (\x0255\x0254\x0000\x0000) no início do arquivo';
      5512: result := 'Erro: XML com caracteres de identificação de codificação UTF-7 ((\x0043\x0047) no início do arquivo';
      5901: result := 'DPEC gerado com sucesso';
      5902: result := 'Erro: Documento XML informado em NFeLote não parece ser um XML válido: [{0:0}]';
      5903: result := 'Erro: XML mal formado [{0:0}]';
      5904: result := 'Erro: O Documento contém mais de uma assinatura digital XML [{0:0}], funcionalidade não preparada para mais de uma assinatura.';
      5905: result := 'Erro: Falha na verificação da Assinatura Digital XML';
      5906: result := 'Erro: A validação da NF-e sem assinatura causa um erro de falta de assinatura que pode ser desprezado [{0:0}]';
      5907: result := 'Erro: Falha ao acessar o cUF da NF-e [{0:0}]';
      5908: result := 'Erro: Falha ao acessar o tpAmbiente da NF-e [{0:0}])';
      5909: result := 'Erro: Falha ao acessar o verProc da NF-e [{0:0}])';
      5910: result := 'Erro: Falha ao acessar o CNPJ do emitente da NF-e [{0:0}])';
      5911: result := 'Erro: Falha ao acessar a IE do emitente da NF-e [{0:0}]';
      5912: result := 'Erro: Falha ao acessar o atributo Id da NF-e [{0:0}]';
      5913: result := 'Erro: Falha ao acessar o CNPJ ou o CPF [{0:0}]';
      5914: result := 'Erro: Falha ao acessar a UF do destinatário/remetente NF-e [{0:0}]';
      5915: result := 'Erro: Falha ao acessar o valor total da NF da NF-e [{0:0}]';
      5916: result := 'Erro: Falha ao acessar o valor do ICMS da NF-e [{0:0}]';
      5917: result := 'Erro: Falha ao acessar o valor do ICMS ST da NF-e [{0:0}]';
      5918: result := 'Erro: Não foi encontrado nenhuma NF-e dentro do NFeLote informado: [{0:0}]';
   end;
end;

//CT-E. Tratar retorno WS
function TRATAR_RET_WS_CTE(cStat: integer): String;
begin
   result := NULL_STRING;
   case cStat of
      100: result := 'Autorizado o uso do CT-e';
      101: result := 'Cancelamento de CT-e homologado';
      102: result := 'Inutilização de número homologado';
      103: result := 'Lote recebido com sucesso';
      104: result := 'Lote processado';
      105: result := 'Lote em processamento';
      106: result := 'Lote não localizado';
      107: result := 'Serviço em Operação';
      108: result := 'Serviço Paralisado Momentaneamente (curto prazo)';
      109: result := 'Serviço Paralisado sem Previsão';
      110: result := 'Uso Denegado';
      111: result := 'Consulta cadastro com uma ocorrência';
      112: result := 'Consulta cadastro com mais de uma ocorrência';
      113: result := 'Serviço SVC em operação. Desativação prevista para a UF em dd/mm/aa, às hh:mm horas';
      114: result := 'SVC-[SP/RS] desabilitada pela SEFAZ de Origem';
      134: result := 'Evento registrado e vinculado ao CT-e com alerta para situação do documento.[Alerta Situação do CT-e: XXXXXXXXXX]';
      135: result := 'Evento registrado e vinculado a CT-e';
      136: result := 'Evento registrado, mas não vinculado a CT-e';
      201: result := 'Rejeição: O número máximo de numeração de CT-e a inutilizar ultrapassou o limite';
      202: result := 'Rejeição: Falha no reconhecimento da autoria ou integridade do arquivo digital';
      203: result := 'Rejeição: Emissor não habilitado para emissão do CT-e';
      204: result := 'Rejeição: Duplicidade de CT-e [nRec:999999999999999]';
      205: result := 'Rejeição: CT-e está denegado na base de dados da SEFAZ';
      206: result := 'Rejeição: Número de CT-e já está inutilizado na Base de dados da SEFAZ';
      207: result := 'Rejeição: CNPJ do emitente inválido';
      208: result := 'Rejeição: CNPJ do destinatário inválido';
      209: result := 'Rejeição: IE do emitente inválida';
      210: result := 'Rejeição: IE do destinatário inválida';
      211: result := 'Rejeição: IE do substituto inválida';
      212: result := 'Rejeição: Data de emissão CT-e posterior a data de recebimento';
      213: result := 'Rejeição: CNPJ-Base do Emitente difere do CNPJ-Base do Certificado Digital';
      214: result := 'Rejeição: Tamanho da mensagem excedeu o limite estabelecido';
      215: result := 'Rejeição: Falha no schema XML';
      216: result := 'Rejeição: Chave de Acesso difere da cadastrada';
      217: result := 'Rejeição: CT-e não consta na base de dados da SEFAZ';
      218: result := 'Rejeição: CT-e já está cancelado na base de dados da SEFAZ';
      219: result := 'Rejeição: Circulação do CT-e verificada';
      220: result := 'Rejeição: CT-e autorizado há mais de 7 dias (168 horas)';
      221: result := 'Rejeição: Confirmado a prestação do serviço do CT-e pelo destinatário';
      222: result := 'Rejeição: Protocolo de Autorização de Uso difere do cadastrado';
      223: result := 'Rejeição: CNPJ do transmissor do lote difere do CNPJ do transmissor da consulta';
      224: result := 'Rejeição: A faixa inicial é maior que a faixa final';
      225: result := 'Rejeição: Falha no Schema XML do CT-e';
      226: result := 'Rejeição: Código da UF do Emitente diverge da UF autorizadora';
      227: result := 'Rejeição: Erro na composição do Campo ID';
      228: result := 'Rejeição: Data de Emissão muito atrasada';
      229: result := 'Rejeição: IE do emitente não informada';
      230: result := 'Rejeição: IE do emitente não cadastrada';
      231: result := 'Rejeição: IE do emitente não vinculada ao CNPJ';
      232: result := 'Rejeição: IE do destinatário não informada';
      233: result := 'Rejeição: IE do destinatário não cadastrada';
      235: result := 'Rejeição: Inscrição SUFRAMA inválida';
      236: result := 'Rejeição: Chave de Acesso com dígito verificador inválido';
      237: result := 'Rejeição: CPF do destinatário inválido';
      238: result := 'Rejeição: Cabeçalho - Versão do arquivo XML superior a Versão vigente';
      239: result := 'Rejeição: Cabeçalho - Versão do arquivo XML não suportada';
      240: result := 'Rejeição: Cancelamento/Inutilização - Irregularidade Fiscal do Emitente';
      241: result := 'Rejeição: Um número da faixa já foi utilizado';
      242: result := 'Rejeição: Elemento cteCabecMsg inexistente no SOAP Header';
      243: result := 'Rejeição: XML Mal Formado';
      245: result := 'Rejeição: CNPJ Emitente não cadastrado';
      246: result := 'Rejeição: CNPJ Destinatário não cadastrado';
      247: result := 'Rejeição: Sigla da UF do Emitente diverge da UF autorizadora';
      248: result := 'Rejeição: UF do Recibo diverge da UF autorizadora';
      249: result := 'Rejeição: UF da Chave de Acesso diverge da UF autorizadora';
      250: result := 'Rejeição: UF diverge da UF autorizadora';
      251: result := 'Rejeição: UF/Município destinatário não pertence a SUFRAMA';
      252: result := 'Rejeição: Ambiente informado diverge do Ambiente de recebimento';
      253: result := 'Rejeição: Dígito Verificador da chave de acesso composta inválido';
      254: result := 'Rejeição: CT-e a ser complementado não informado para CT-e complementar';
      256: result := 'Rejeição: Um número de CT-e da faixa está inutilizado na Base de dados da SEFAZ';
      257: result := 'Rejeição: Solicitante não habilitado para emissão do CT-e';
      258: result := 'Rejeição: CNPJ da consulta inválido';
      259: result := 'Rejeição: CNPJ da consulta não cadastrado como contribuinte na UF';
      260: result := 'Rejeição: IE da consulta inválida';
      261: result := 'Rejeição: IE da consulta não cadastrada como contribuinte na UF';
      262: result := 'Rejeição: UF não fornece consulta por CPF';
      263: result := 'Rejeição: CPF da consulta inválido';
      264: result := 'Rejeição: CPF da consulta não cadastrado como contribuinte na UF';
      265: result := 'Rejeição: Sigla da UF da consulta difere da UF do Web Service';
      266: result := 'Rejeição: Série utilizada não permitida no Web Service';
      267: result := 'Rejeição: CT-e Complementar referencia um CT-e inexistente';
      268: result := 'Rejeição: CT-e Complementar referencia outro CT-e Complementar';
      269: result := 'Rejeição: CNPJ Emitente do CT-e Complementar difere do CNPJ do CT complementado';
      270: result := 'Rejeição: Código Município do Fato Gerador: dígito inválido';
      271: result := 'Rejeição: Código Município do Fato Gerador: difere da UF do emitente';
      272: result := 'Rejeição: Código Município do Emitente: dígito inválido';
      273: result := 'Rejeição: Código Município do Emitente: difere da UF do emitente';
      274: result := 'Rejeição: Código Município do Destinatário: dígito inválido';
      275: result := 'Rejeição: Código Município do Destinatário: difere da UF do Destinatário';
      276: result := 'Rejeição: Código Município do Local de Retirada: dígito inválido';
      277: result := 'Rejeição: Código Município do Local de Retirada: difere da UF do Local de Retirada';
      278: result := 'Rejeição: Código Município do Local de Entrega: dígito inválido';
      279: result := 'Rejeição: Código Município do Local de Entrega: difere da UF do Local de Entrega';
      280: result := 'Rejeição: Certificado Transmissor inválido';
      281: result := 'Rejeição: Certificado Transmissor Data Validade';
      282: result := 'Rejeição: Certificado Transmissor sem CNPJ';
      283: result := 'Rejeição: Certificado Transmissor - erro Cadeia de Certificação';
      284: result := 'Rejeição: Certificado Transmissor revogado';
      285: result := 'Rejeição: Certificado Transmissor difere ICP-Brasil';
      286: result := 'Rejeição: Certificado Transmissor erro no acesso a LCR';
      289: result := 'Rejeição: Código da UF informada diverge da UF solicitada';
      290: result := 'Rejeição: Certificado Assinatura inválido';
      291: result := 'Rejeição: Certificado Assinatura Data Validade';
      292: result := 'Rejeição: Certificado Assinatura sem CNPJ';
      293: result := 'Rejeição: Certificado Assinatura - erro Cadeia de Certificação';
      294: result := 'Rejeição: Certificado Assinatura revogado';
      295: result := 'Rejeição: Certificado Assinatura difere ICP-Brasil';
      296: result := 'Rejeição: Certificado Assinatura erro no acesso a LCR';
      297: result := 'Rejeição: Assinatura difere do calculado';
      298: result := 'Rejeição: Assinatura difere do padrão do Projeto';
      299: result := 'Rejeição: XML da área de cabeçalho com codificação diferente de UTF-8';
      301: result := 'Uso Denegado: Irregularidade fiscal do emitente';
      401: result := 'Rejeição: CPF do remetente inválido';
      402: result := 'Rejeição: XML da área de dados com codificação diferente de UTF-8';
      404: result := 'Rejeição: Uso de prefixo de namespace não permitido';
      405: result := 'Rejeição: Código do país do emitente: dígito inválido';
      406: result := 'Rejeição: Código do país do destinatário: dígito inválido';
      407: result := 'Rejeição: O CPF só pode ser informado no campo emitente para o CT-e avulso';
      408: result := 'Rejeição: Lote com CT-e de diferentes UF';
      409: result := 'Rejeição: Campo cUF inexistente no elemento cteCabecMsg do SOAP Header';
      410: result := 'Rejeição: UF informada no campo cUF não é atendida pelo WebService';
      411: result := 'Rejeição: Campo versaoDados inexistente no elemento cteCabecMsg do SOAP Header';
      413: result := 'Rejeição: Código de Município de término da prestação: dígito inválido';
      414: result := 'Rejeição: Código de Município diverge da UF de término da prestação';
      415: result := 'Rejeição: CNPJ do remetente inválido';
      416: result := 'Rejeição: CPF do remetente inválido';
      417: result := 'Rejeição: Código de Município de localização remetente: dígito inválido';
      418: result := 'Rejeição: Código de Município diverge da UF de localização remetente';
      419: result := 'Rejeição: IE do remetente inválida';
      420: result := 'Rejeição: CNPJ remetente não cadastrado';
      421: result := 'Rejeição: IE do remetente não cadastrada';
      422: result := 'Rejeição: IE do remetente não vinculada ao CNPJ';
      423: result := 'Rejeição: Código de Município de localização destinatário: dígito inválido';
      424: result := 'Rejeição: Código de Município diverge da UF de localização destinatário';
      425: result := 'Rejeição: CNPJ destinatário não cadastrado';
      426: result := 'Rejeição: IE do destinatário não cadastrada';
      427: result := 'Rejeição: IE do destinatário não vinculada ao CNPJ';
      428: result := 'Rejeição: CNPJ do expedidor inválido';
      429: result := 'Rejeição: CPF do expedidor inválido';
      430: result := 'Rejeição: Código de Município de localização expedidor: dígito inválido';
      431: result := 'Rejeição: Código de Município diverge da UF de localização expedidor';
      432: result := 'Rejeição: IE do expedidor inválida';
      433: result := 'Rejeição: CNPJ expedidor não cadastrado';
      434: result := 'Rejeição: IE do expedidor não cadastrada';
      435: result := 'Rejeição: IE do expedidor não vinculada ao CNPJ';
      436: result := 'Rejeição: CNPJ do recebedor inválido';
      437: result := 'Rejeição: CPF do recebedor inválido';
      438: result := 'Rejeição: Código de Município de localização do recebedor: dígito inválido';
      439: result := 'Rejeição: Código de Município diverge da UF de localização recebedor';
      440: result := 'Rejeição: IE do recebedor inválida';
      441: result := 'Rejeição: CNPJ recebedor não cadastrado';
      442: result := 'Rejeição: IE do recebedor não cadastrada';
      443: result := 'Rejeição: IE do recebedor não vinculada ao CNPJ';
      444: result := 'Rejeição: CNPJ do tomador inválido';
      445: result := 'Rejeição: CPF do tomador inválido';
      446: result := 'Rejeição: Código de Município de localização tomador: dígito inválido';
      447: result := 'Rejeição: Código de Município diverge da UF de localização tomador';
      448: result := 'Rejeição: IE do tomador inválida';
      449: result := 'Rejeição: CNPJ tomador não cadastrado';
      455: result := 'Rejeição: Código de Município de início da prestação: dígito inválido';
      456: result := 'Rejeição: Código de Município diverge da UF de início da prestação';
      457: result := 'Rejeição: O lote contém CT-e de mais de um estabelecimento emissor';
      458: result := 'Rejeição: Grupo de CT-e normal não informado para CT-e normal';
      459: result := 'Rejeição: Grupo de CT-e complementar não informado para CT-e complementar';
      460: result := 'Rejeição: Não informado os dados do remetente indicado como tomador do serviço';
      461: result := 'Rejeição: Não informado os dados do expedidor indicado como tomador do serviço';
      462: result := 'Rejeição: Não informado os dados do recebedor indicado como tomador do serviço';
      463: result := 'Rejeição: Não informado os dados do destinatário indicado como tomador do serviço';
      469: result := 'Rejeição: Remetente deve ser informado para tipo de serviço diferente de redespacho intermediário ou Serviço vinculado a multimodal';
      470: result := 'Rejeição: Destinatário deve ser informado para tipo de serviço diferente de redespacho intermediário ou serviço vinculado a multimodal';
      471: result := 'Rejeição: Ano de inutilização não pode ser superior ao Ano atual';
      472: result := 'Rejeição: Ano de inutilização não pode ser inferior a 2008';
      473: result := 'Rejeição: Tipo Autorizador do Recibo diverge do Órgão Autorizador';
      474: result := 'Rejeição: Expedidor deve ser informado para tipo de serviço de redespacho intermediário e serviço vinculado a multimodal';
      475: result := 'Rejeição: Recebedor deve ser informado para tipo de serviço de redespacho intermediário e serviço vinculado a multimodal';
      489: result := 'Rejeição: IE do tomador não cadastrada';
      490: result := 'Rejeição: IE do tomador não vinculada ao CNPJ';
      491: result := 'Rejeição: CT-e referenciado é CT-e complementar';
      492: result := 'Rejeição: Código de Município de envio: dígito inválido';
      493: result := 'Rejeição: Código de Município diverge da UF de envio';
      494: result := 'Rejeição: Processo de emissão informado inválido';
      495: result := 'Rejeição: Solicitante não autorizado para consulta';
      496: result := 'Rejeição: Grupo CT-e de Anulação não informado para o CT-e de Anulação';
      497: result := 'Rejeição: CT-e objeto da anulação inexistente';
      498: result := 'Rejeição: CT-e objeto da anulação deve estar com a situação autorizada (não pode estar cancelado ou denegado)';
      499: result := 'Rejeição: CT-e de anulação deve ter tipo de emissão = normal';
      500: result := 'Rejeição: CT-e objeto da anulação deve ter Tipo = 0 (normal) ou 3 (Substituição)';
      501: result := 'Rejeição: Data de emissão do CT-e de Anulação deve ocorrer em até 60 dias';
      502: result := 'Rejeição: CT-e de anulação deve ter o valor do ICMS e de prestação iguais ao CT-e original';
      503: result := 'Rejeição: CT-e substituto deve ter tipo de emissão = normal';
      505: result := 'Rejeição: Grupo CT-e de Substituição não informado para o CT-e de Substituição';
      510: result := 'Rejeição: CNPJ do emitente do CT-e substituto deve ser igual ao informado no CT-e substituído';
      511: result := 'Rejeição: CNPJ/CPF do remetente do CT-e substituto deve ser igual ao informado no CT-e substituído';
      512: result := 'Rejeição: CNPJ/CPF do destinatário do CT-e substituto deve ser igual ao informado no CT-e substituído';
      513: result := 'Rejeicao: UF nao atendida pela SVC-[SP/RS]';
      514: result := 'Rejeição: versão da mensagem não suportada na SVC';
      515: result := 'Rejeição: O tpEmis informado só é válido na contingência SVC';
      516: result := 'Rejeição: O tpEmis informado é incompatível com SVC-[SP/RS]';
      517: result := 'Rejeição: CT-e informado em SVC deve ser Normal';
      518: result := 'Rejeição: Serviço indisponível na SVC';
      539: result := 'Rejeicao: Duplicidade de CT-e, com diferença na Chave de Acesso [chCTe:99999999999999999999999999999999999999999999][nRec:999999999999999]';
      540: result := 'Rejeição: Grupo de documentos informado inválido para remetente que emite NF-e';
      550: result := 'Rejeição: O CNPJ/CPF do expedidor do CT-e substituto deve ser igual ao informado no CT-e substituído';
      551: result := 'Rejeição: O CNPJ/CPF do recebedor do CT-e substituto deve ser igual ao informado no CT-e substituído';
      552: result := 'Rejeição: O CNPJ/CPF do tomador do CT-e substituto deve ser igual ao informado no CT-e substituído';
      553: result := 'Rejeição: A IE do emitente do CT-e substituto deve ser igual ao informado no CT-e substituído';
      554: result := 'Rejeição: A IE do remetente do CT-e substituto deve ser igual ao informado no CT-e substituído';
      555: result := 'Rejeição: A IE do destinatário do CT-e substituto deve ser igual ao informado no CT-e substituído';
      556: result := 'Rejeição: A IE do expedidor do CT-e substituto deve ser igual ao informado no CT-e substituído';
      557: result := 'Rejeição: A IE do recebedor do CT-e substituto deve ser igual ao informado no CT-e substituído';
      558: result := 'Rejeição: A IE do tomador do CT-e substituto deve ser igual ao informado no CT-e substituído';
      559: result := 'Rejeição: A UF de início da prestação deve ser igual ao informado no CT-e substituído';
      560: result := 'Rejeição: A UF de fim da prestação deve ser igual ao informado no CT-e substituído';
      561: result := 'Rejeição: O valor da prestação do serviço deve ser menor ou igual ao informado no CT-e substituído';
      562: result := 'Rejeição: O valor do ICMS do CT-e substituto deve ser menor ou igual ao informado no CT-e substituído';
      563: result := 'Rejeição: A substituição de um CT-e deve ocorrer no prazo máximo de 90 dias contados da data de emissão do CT-e objeto de Substituição';
      564: result := 'Rejeição: O CT-e de anulação não pode ser cancelado';
      565: result := 'Rejeição: O CT-e só pode ser anulado pelo emitente';
      566: result := 'Rejeição: CT-e objeto da anulação não pode ter sido anulado anteriormente';
      567: result := 'Rejeição: CT-e objeto da anulação não pode ter sido substituído anteriormente';
      568: result := 'Rejeição: CT-e a ser substituído inexistente';
      569: result := 'Rejeição: CT-e a ser substituído deve estar com a situação autorizada (não pode estar cancelado ou denegado)';
      570: result := 'Rejeição: CT-e a ser substituído não pode ter sido substituído anteriormente';
      571: result := 'Rejeição: CT-e a ser substituído deve ter Tipo = 0 (normal) ou 3 (Substituição)';
      572: result := 'Rejeição: CT-e de anulação informado no grupo Tomador não é contribuinte do ICMS inexistente';
      573: result := 'Rejeição: CT-e de anulação informado no grupo Tomador não é contribuinte do ICMS deve ter Tipo=2(Anulação)';
      574: result := 'Rejeição: Vedado o cancelamento de CT-e do tipo substituto (tipo=3)';
      575: result := 'Rejeição: Vedado o cancelamento se possuir CT-e de Anulação associado';
      576: result := 'Rejeição: Vedado o cancelamento se possuir CT-e de Substituição associado';
      577: result := 'Rejeição: CT-e a ser substituído não pode ter sido anulado anteriormente';
      578: result := 'Rejeição: Chave de acesso do CT-e anulado deve ser igual ao substituído';
      579: result := 'Rejeição: Versão informada para o modal não suportada';
      580: result := 'Rejeição: Falha no Schema XML específico para o modal';
      581: result := 'Rejeição: Campo Valor da Carga deve ser informado para o modal';
      582: result := 'Rejeição: Grupo Tráfego Mútuo deve ser informado';
      583: result := 'Rejeição: Ferrovia emitente deve ser a de origem quando respFat=1';
      584: result := 'Rejeição: Referenciar o CT-e que foi emitido pela ferrovia de origem';
      585: result := 'Rejeição: IE Emitente não autorizada a emitir CT-e para o modal informado';
      586: result := 'Rejeição: Data e Justificativa de entrada em contingência não devem ser informadas para tipo de emissão normal.';
      587: result := 'Rejeição: Data e Justificativa de entrada em contingência devem ser informadas';
      588: result := 'Rejeição: Data de entrada em contingência posterior a data de emissão.';
      589: result := 'Rejeição: O lote contém CT-e de mais de um modal';
      590: result := 'Rejeição: O lote contém CT-e de mais de uma versão de modal';
      591: result := 'Rejeição: Dígito Verificador inválido na Chave de acesso de NF-e transportada';
      592: result := 'Rejeição: Chave de acesso inválida (Ano < 2009 ou Ano maior que Ano corrente)';
      593: result := 'Rejeição: Chave de acesso inválida (Mês = 0 ou Mês > 12)';
      594: result := 'Rejeição: Chave de acesso inválida (CNPJ zerado ou digito inválido)';
      595: result := 'Rejeição: Chave de acesso inválida (modelo diferente de 57)';
      596: result := 'Rejeição: Chave de acesso inválida (numero CT = 0)';
      598: result := 'Rejeicao: Usar somente o namespace padrao do CT-e';
      599: result := 'Rejeicao: Nao eh permitida a presenca de caracteres de edicao no inicio/fim da mensagem ou entre as tags da mensagem';
      600: result := 'Rejeicao: Chave de Acesso difere da existente em BD';
      601: result := 'Rejeição: Quantidade de documentos informados no remetente excede limite de 2000';
      602: result := 'Rejeição: Chave de acesso de NF-e inválida (Ano < 2005 ou Ano maior que Ano corrente)';
      603: result := 'Rejeição: Chave de acesso de NF-e inválida (Mês = 0 ou Mês > 12)';
      604: result := 'Rejeição: Chave de acesso de NF-e inválida (CNPJ zerado ou digito inválido)';
      605: result := 'Rejeição: Chave de acesso de NF-e inválida (modelo diferente de 55)';
      606: result := 'Rejeição: Chave de acesso de NF-e inválida (numero NF = 0)';
      627: result := 'Rejeição: CNPJ do autor do evento inválido';
      628: result := 'Rejeição: Erro Atributo ID do evento não corresponde a concatenação dos campos (ID + tpEvento + chCTe + nSeqEvento)';
      629: result := 'Rejeição: O tpEvento informado inválido';
      630: result := 'Rejeição: Falha no Schema XML específico para o evento';
      631: result := 'Rejeição: Duplicidade de evento';
      632: result := 'Rejeição: O autor do evento diverge do emissor do CT-e';
      633: result := 'Rejeição: O autor do evento não é um órgão autorizado a gerar o evento';
      634: result := 'Rejeição: A data do evento não pode ser menor que a data de emissão do CT-e';
      635: result := 'Rejeição: A data do evento não pode ser maior que a data do processamento';
      636: result := 'Rejeição: O numero sequencial do evento é maior que o permitido';
      637: result := 'Rejeição: A data do evento não pode ser menor que a data de autorização do CT-e';
      638: result := 'Rejeição: Já existe CT-e autorizado com esta numeração';
      639: result := 'Rejeição: Existe EPEC emitido há mais de 7 dias (168h) sem a emissão do CT-e no ambiente normal de autorização';
      640: result := 'Rejeição: Tipo de emissão do CT-e difere de EPEC com EPEC autorizado na SVC-XX para este documento.';
      641: result := 'Rejeição: O evento prévio deste CT-e não foi autorizado na SVC ou ainda não foi sincronizado.[OBS: Em caso de atraso na sincronização, favor aguardar alguns instantes para nova tentativa de transmissão]';
      642: result := 'Rejeição: Os valores de ICMS, Prestação e Total da Carga do CT-e devem ser iguais aos informados no EPEC.';
      643: result := 'Rejeição: As informações do tomador de serviço do CT-e devem ser iguais as informadas no EPEC';
      644: result := 'Rejeição: A informação do modal do CT-e deve ser igual a informada no EPEC';
      645: result := 'Rejeição: A UF de inicio e fim de prestação do CT-e devem ser iguais as informadas no EPEC.';
      646: result := 'Rejeição: CT-e emitido em ambiente de homologação com Razão Social do remetente diferente de CT-E EMITIDO EM AMBIENTE DE HOMOLOGACAO - SEM VALOR FISCAL';
      647: result := 'Rejeição: CT-e emitido em ambiente de homologação com Razão Social do expedidor diferente de CT-E EMITIDO EM AMBIENTE DE HOMOLOGACAO - SEM VALOR FISCAL';
      648: result := 'Rejeição: CT-e emitido em ambiente de homologação com Razão Social do recebedor diferente de CT-E EMITIDO EM AMBIENTE DE HOMOLOGACAO - SEM VALOR FISCAL';
      649: result := 'Rejeição: CT-e emitido em ambiente de homologação com Razão Social do destinatário diferente de CT-E EMITIDO EM AMBIENTE DE HOMOLOGACAO - SEM VALOR FISCAL';
      650: result := 'Rejeição: Valor total do serviço superior ao limite permitido (R$ 9.999.999,99)';
      651: result := 'Rejeição: Referenciar o CT-e Multimodal que foi emitido pelo OTM';
      652: result := 'Rejeição: NF-e não pode estar cancelada ou denegada';
      653: result := 'Rejeição: Tipo de evento não é permitido em ambiente de autorização Normal';
      654: result := 'Rejeição: Tipo de evento não é permitido em ambiente de autorização SVC';
      655: result := 'Rejeição: CT-e complementado deve estar com a situação autorizada (não pode estar cancelado ou denegado)';
      656: result := 'Rejeição: CT-e complementado não pode ter sido anulado';
      657: result := 'Rejeição: CT-e complementado não pode ter sido substituído';
      658: result := 'Rejeição: CT-e objeto da anulação não pode ter sido complementado';
      659: result := 'Rejeição: CT-e substituído não pode ter sido complementado';
      660: result := 'Rejeição: Vedado o cancelamento se possuir CT-e Complementar associado';
      661: result := 'Rejeição: NF-e inexistente na base de dados da SEFAZ';
      662: result := 'Rejeição: NF-e com diferença de Chave de Acesso';
      663: result := 'Rejeição: CT-e autorizado há mais de 30 dias';
      664: result := 'Rejeição: Evento não permitido para CT-e Substituido/Anulado';
      665: result := 'Rejeição: As informações do seguro da carga devem ser preenchidas para o modal rodoviário';
      666: result := 'Rejeição: O responsável pelo seguro da carga indicado não foi relacionado no CT-e';
      667: result := 'Rejeição: CNPJ do Tomador deve ser igual ao CNPJ do Emitente do CT-e Multimodal';
      668: result := 'Rejeição: CPF do funcionário do registro de passagem inválido';
      669: result := 'Rejeição: Segundo código de barras deve ser informado para CT-e emitido em contingência FS-DA';
      670: result := 'Rejeição: Série utilizada não permitida no webservice';
      671: result := 'Rejeição: CT-e referenciado no CT-e Complementar com diferença de Chave de Acesso [chCTe: 99999999999999999999999999999999999999999999][nRec:999999999999999]';
      672: result := 'Rejeição: CT-e de Anulação com diferença de Chave de Acesso [chCTe: 99999999999999999999999999999999999999999999][nRec:999999999999999]';
      673: result := 'Rejeição: CT-e Substituído com diferença de Chave de Acesso [chCTe: 99999999999999999999999999999999999999999999][nRec]';
      674: result := 'Rejeição: CT-e Objeto de Anulação com diferença de Chave de Acesso [chCTe: 99999999999999999999999999999999999999999999][nRec]';
      675: result := 'Rejeição: Valor do imposto não corresponde a base de calculo X aliquota';
      676: result := 'Rejeição: CFOP informado inválido';
      677: result := 'Rejeição: Órgão de recepção do evento inválido';
      678: result := 'Rejeição: Consumo Indevido [Descrição: XXXXXXXXXXXXXXXXXXXXXXXXXXXX]';
      679: result := 'Rejeição: O modal do CT-e deve ser Multimodal para Evento Registros do Multimodal';
      680: result := 'Rejeição: Tipo de Emissão diferente de EPEC';
      681: result := 'Rejeição: Informação não pode ser alterada por carta de correção';
      682: result := 'Rejeição: Já existe pedido de inutilização com a mesma faixa de inutilização';
      683: result := 'Rejeição: Chave de acesso de MDF-e inválida (Ano < 2012 ou Ano maior que Ano corrente)';
      684: result := 'Rejeição: Chave de acesso de MDF-e inválida (Mês = 0 ou Mês > 12)';
      685: result := 'Rejeição: Chave de acesso de MDF-e inválida (CNPJ zerado ou digito inválido)';
      686: result := 'Rejeição: Chave de acesso de MDF-e inválida (modelo diferente de 58)';
      687: result := 'Rejeição: Chave de acesso de MDF-e inválida (numero MDF = 0)';
      688: result := 'Rejeição: Grupo de informações do veiculo deve ser informado para Carga Lotação';
      689: result := 'Rejeição: CT-e de anulação não é permitido para CT-e cujo tomador é Contribuinte de ICMS.';
      690: result := 'Rejeição: CT-e Multimodal referenciado inexistente na base de dados da SEFAZ';
      691: result := 'Rejeição: CT-e Multimodal referenciado existe com diferença de chave de acesso';
      692: result := 'Rejeição: CT-e Multimodal referenciado não pode estar cancelado ou denegado';
      693: result := 'Rejeição: Grupo Documentos Transportados deve ser informado para tipo de serviço diferente de redespacho intermediário e serviço vinculado a multimodal';
      694: result := 'Rejeição: Grupo Documentos Transportados não pode ser informado para tipo de serviço redespacho intermediário e serviço vinculado a multimodal';
      695: result := 'Rejeição: CT-e com emissão anterior ao evento prévio (EPEC)';
      696: result := 'Rejeição:Existe EPEC aguardando CT-e nessa faixa de numeração';
      697: result := 'Rejeição: Data de emissão do CT-e deve ser igual a data de autorização da EPEC';
      698: result := 'Rejeição: Evento Prévio autorizado há mais de 7 dias (168 horas)';
      699: result := 'Rejeição: CNPJ autorizado para download inválido';
      700: result := 'Rejeição: CPF autorizado para download inválido';
      998: result := 'Rejeição: CT-e Multimodal e Serviço Vinculado a Multimodal não estão liberados no ambiente de produção. *** Regra provisória';
      999: result := 'Rejeição: Erro não catalogado (informar a mensagem de erro capturado no tratamento da exceção)';
   end;
end;


function GetIP: String;
var
   WSAData: TWSAData;
   HostEnt: PHostEnt;
   Name   : String;
begin
   WSAStartup(2, WSAData);
   SetLength(Name, 255);
   Gethostname(PAnsiChar(Name), 255);
   SetLength(Name, StrLen(PChar(Name)));
   HostEnt := gethostbyname(PAnsiChar(Name));
   with HostEnt^ do
      Result := Format('%d.%d.%d.%d',[Byte(h_addr^[0]),
                     Byte(h_addr^[1]), Byte(h_addr^[2]), Byte(h_addr^[3])]);
   WSACleanup;
end;

//Abre um programa externo
procedure AbrirPrograma(caminho: string);
begin
   ShellExecute(HANDLE_FLAG_INHERIT, 'open', PChar(caminho), '', '', SW_SHOWMAXIMIZED);
end;

//Fechar um programa externo
procedure FecharPrograma(caminho: string);
begin
   ShellExecute(HANDLE_FLAG_INHERIT, 'close', PChar(caminho), '', '', SW_SHOWMAXIMIZED);
end;

function EhCFOPEntrada(cfop: string): boolean;
begin
   try
      result := StrToInt(Copy(cfop, 1, 1)) IN [1,2,3];
   except
      Application.MessageBox('CFOP não informado.', MT_ALERTA, MB_OK + MB_ICONWARNING);
   end;
end;

function TiraPontos(Str: string): string;
var
   i: Integer;
   xStr : String;
begin
   xStr := '';
   for i:=1 to Length(Trim(str)) do
      if (Pos(Copy(str,i,1),'/-.)(,')=0) then
         xStr := xStr + str[i];
   xStr := StringReplace(xStr,' ','',[rfReplaceAll]);
   Result:=xStr;
end;

function Space(Tamanho: Integer): string;
var
   i: Integer;
begin
   Result:='';
   for i:=1 to Tamanho do Result:=Result+' ';
end;

function RemoveZerosEsquerda(S: string): string;
var
   I, J : Integer;
begin
   I := Length(S);
   while (I > 0) and (S[I] <= ' ') do
      Dec(I);
   J := 1;
   while (J < I) and ((S[J] <= ' ') or (S[J] = '0')) do
      Inc(J);
   result := Copy(S, J, (I-J)+1);
end;

function RemoveZerosDireita(S: string): string;
var
   I, J : Integer;
begin
   I := Length(S);
   while (I > 0) and (S[I] <= '0') do
      Dec(I);
   J := 1;
   while (J < I) and ((S[J] <= '0') or (S[J] = '0')) do
      Inc(J);
   result := Copy(S, J, (I - J) + 1);
end;

function removerEspacoBrancoComecoFim(palavra: String): String;
var
   Tamanho, varredor: Integer;
begin
   varredor := 1;
   tamanho  := Length(palavra);

   while (tamanho > varredor) do
   begin
      if (varredor = 1) Then
      begin
         if not (palavra[varredor] = ' ') Then
            result := result + palavra[varredor];
      end
      else if (varredor = tamanho) Then
      begin
         if not (palavra[varredor] = ' ') Then
            result := result + palavra[varredor];
      end
      else
         result := result + palavra[varredor];
      //incrementa o varredor.
      varredor := varredor + 1;
   end;
end;

//Retorna o Ultimo dia do mes de uma determinada data
function UltDiaDoMes(Data: TDateTime): Word;
var
   d, m, a: Word;
   dt: TDateTime;
begin
   DecodeDate(Data, a,m,d);
   Inc(m);
   if m = 13 then
      m := 1;
   dt := EncodeDate(a, m, 1);
   dt := dt - 1;
   DecodeDate(dt, a, m, d);
   Result := d;
end;

//Verificar se um diretorio existe
function DiretorioExiste(Dir: string): boolean;
begin
   if (Copy(Dir, length(Dir), 1) = '\') then
      Dir := Copy(Dir, 1, length(Dir) - 1);

   result := DirectoryExists(Dir);
end;

//Valida estado
Function ValidaEstado(Dado : string) : boolean;
const
  Estados = 'SPMGRJRSSCPRESDFMTMSGOTOBASEALPBPEMARNCEPIPAAMAPFNACRRRO';
var
  Posicao : integer;
begin
   Result := true;
   if Dado <> '' then
   begin
      Posicao := Pos(UpperCase(Dado),Estados);
      if (Posicao = 0) or ((Posicao mod 2) = 0) then
         Result := false;
   end;
end;

//Valida CST ICMS
Function ValidaCSTICMS(Dado : string) : boolean;
const
   ListaCST: Array[0..63] of String = ('000', '010', '020', '030',
                                       '040', '041', '050', '051',
                                       '060', '070', '073', '075',
                                       '090', '100', '110', '120',
                                       '130', '140', '141', '150',
                                       '151', '160', '170', '173',
                                       '175', '190', '200', '210',
                                       '220', '230', '240', '241',
                                       '250', '251', '260', '270',
                                       '273', '275', '290', '300',
                                       '400', '500', '900', '101',
                                       '201', '202', '203', '390',
                                       '490', '590', '690', '790',
                                       '890', '360', '460', '560',
                                       '660', '760', '860', '102',
                                       '103', '310', '520', '600');
var
   i : Integer;
begin
   i := 0;
   result := false;
   while ((not result) and (i <= 63)) do
   begin
      result := ListaCST[i] = Dado;
      inc(i);
   end;
end;

Function AprovarCST(CST: String; opatantePeloSimples: boolean): Boolean;
const
   LSTCSTSIMPLES: array[0..9] of string  = ('101', '102', '103', '201', '202', '203', '300', '400', '500', '900');
   LSTCST       : array[0..35] of string = ('000', '010', '020', '030', '040', '041', '050', '051', '060', '070',
                                            '090', '100', '110', '120', '130', '140', '141', '150', '151', '160',
                                            '170', '190', '200', '210', '220', '230', '240', '241', '250', '251',
                                            '260', '270', '290', '500', '520', '600');
var
   i: integer;
begin
   //CSOSN internacional
   result := Length(Trim(cst)) = 4;

   if not result then
   begin
      i := 0;

      if ValidaCSTICMS(CST) Then
      begin
         if opatantePeloSimples Then
         begin
            while ((not result) and (i <= 9)) do
            begin
               result := LSTCSTSIMPLES[i] = CST;
               inc(i);
            end;
         end
         else
         begin
            while ((not result) and (i <= 35)) do
            begin
               result := LSTCST[i] = CST;
               inc(i);
            end;
         end;
      end;
   end;
end;

Function AprovarAliquotaCSTICMS(Aliquota: Currency; CST: String): Boolean;
const
   LSTCSTNAOTRIBUTADA          : array[0..21] of string  = ('040', '041', '050', '051', '060', '070', '300', '400', '500', '900', '140', '141', '150', '151', '160', '170', '240', '241', '250', '251', '260', '270');
   LSTCSTTRIBUTADA             : array[0..24] of string = ('000', '010', '020', '030', '090', '101', '102', '103', '201', '202', '203', '100', '110', '120', '130', '190', '200', '210', '220', '230', '290', '900', '500', '520', '600');
var
   i            : integer;
begin
   result := False;
   i      := 0;

   if Aliquota > 0 Then
   begin
      while ((not result) and (i <= 24)) do
      begin
         result := LSTCSTTRIBUTADA[i] = CST;
         inc(i);
      end;
   end
   else
   begin
      while ((not result) and (i <= 21)) do
      begin
         result := LSTCSTNAOTRIBUTADA[i] = CST;
         inc(i);
      end;
   end;
end;

//Apaga arquivos usando mascaras tipo: c:\Temp\*.zip, c:\Temp\*.* Obs: Requer o Path dos arquivos a serem deletados
Procedure ZapFiles(vMasc: String);
var
   Dir : TsearchRec;
   Erro: Integer;
   arquivo: PAnsiChar;
begin
   Erro := FindFirst(vMasc,faArchive,Dir);
   while Erro = 0 do
   begin
      arquivo := PAnsiChar(ExtractFilePAth(vMasc) + Dir.Name);
      DeleteFileA(arquivo);
      Erro := FindNext(Dir);
   end;
   FindClose(Erro);
end;

//esconde ou exibe a barra do Windows
Procedure SetTaskBar(Visible: Boolean);
var
  wndHandle : THandle;
  wndClass : array[0..50] of Char;
begin
  StrPCopy(@wndClass[0],'Shell_TrayWnd');
  wndHandle := FindWindow(@wndClass[0], nil);
  if Visible = True then
     ShowWindow(wndHandle, SW_RESTORE)
  else
     ShowWindow(wndHandle, SW_HIDE);
end;

function MD5File(const fileName: string): string;
var
  idmd5 : TIdHashMessageDigest5;
  fs : TFileStream;
begin
  idmd5 := TIdHashMessageDigest5.Create;
  fs := TFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite) ;
  try
//    result := idmd5.AsHex(idmd5.HashValue(fs))
    result := idmd5.HashStreamAsHex(fs)
  finally
    fs.Free;
    idmd5.Free;
  end;
end;

function MD5String(const texto: string): string;
var
  idmd5: TIdHashMessageDigest5;
begin
  idmd5 := TIdHashMessageDigest5.Create;
  try
//    result := idmd5.AsHex(idmd5.HashValue(texto));
    result := idmd5.HashStringAsHex(texto);
  finally
   idmd5.Free;
  end;
end;

//enviar email para
function EnviarEmail(porta, host, usuario, senha, cabecalho, corpo, emailRemetente, nomeRemetente, emailDestinatario, nomeDestinatario, anexo, chaveAcesso, arquivoPDF: string): boolean;
var
  Email : TIdMessage;
  Texto : TIdText;
  Html  : TIdText;
  idSMTP: TIdSMTP;
begin
   result := false;
   idSMTP := TIdSMTP.Create(nil);
   Email := TIdMessage.Create(nil);
   try
      if corpo = NULL_STRING then
         corpo := nomeDestinatario;

      if cabecalho = NULL_STRING then
         cabecalho := 'Arquivo de nota fiscal';
      Email.Subject := cabecalho;

      // define o tipo do conteúdo da mensagem
      Email.ContentType := 'multipart/mixed';

      // cria a parte texto - pode estar em branco
      Texto := TIdText.Create(Email.MessageParts);
      Texto.Body.Text :=
        'This message contains HTML and images.';
      Texto.ContentType := 'text/plain';

      // cria a parte HTML
      Html := TIdText.Create(Email.MessageParts);
      Html.Body.Text :=
         '<html>' +
           '<head>' +
             '<title>ENVIO DE NFE EMAIL</title>' +
             '<meta http-equiv="Content-Type" content="utf-8" />' +
             '<style type="text/css">' +
               'body {  font-family: verdana, helvetica, sans-serif; margin: 0px; padding: 0; }' +
               'h1 { font-weight: bold; font-size: 150%; border-bottom-style: solid; border-bottom-width: 2px; margin-top: 0px; padding-bottom: 0.5ex; color: #eeeeee; }' +
               'h2 { font-size: 130%; padding-bottom: 0.5ex; color: #009ACE; border-bottom-style: solid; border-bottom-width: 2px; }' +
               'h3 { font-size: 110%; padding-bottom: 0.5ex; color: #000000; }' +
               'th { text-align: left; background-color: #009ACE; color: #eeeeee; }' +
               '#ReportHeader { padding: 10px; background-color: #009ACE; color: #eeeeee; border-bottom-style: solid; border-bottom-width: 2px; border-color: #999999; }' +
               '#ReportHeader th { width: 25%; white-space: nowrap; vertical-align: top; }' +
               '#ReportHeader td { vertical-align: top; color: #eeeeee; }' +
             '</style>' +
           '</head>' +
           '<body>' +
             '<div id="ReportHeader"><h1>' + nomeRemetente + '</h1>' +
                  '<b>Destinatario: </b>' + RemoverCaracterEspecial(corpo) + '<br />' +
                  '<b>Chave de acesso: </b>' + chaveAcesso + '<br />' +
             '<br /></div>' +
             '<div id="ReportDetails">' +
               '<h3>O arquivo .xml referente a esta NFe segue em anexo</h3>' +
             '</div>' +
             //'<img src="cid:logo.jpg" />' +
           '</body>' +
         '</html>';
      Html.ContentType := 'text/html';

      // inclui no email a imagem usada na parte HTML
      {Anexo2 := TIdAttachment.Create(Email.MessageParts, 'C:\Arquivos de programas\Intech Sistemas\logo.jpg');
      Anexo2.ContentType := 'image/jpg';
      Anexo2.Headers.Add('Content-ID: <imagem.jpg>');}


      //Configuracando conexao do email
      idSMTP.Port               := StrToInt(porta); //25;
      idSMTP.Host               := host; //'mail.intechsistemas.com.br';
      idSMTP.Username           := usuario; //'intech@intechsistemas.com.br';
      idSMTP.Password           := senha; //'desdobro';
      idSMTP.AuthType           := satDefault; //atLogin;
//      idSMTP.AuthenticationType := atLogin;


      //Configuracao Remetente/Destinatario
      Email.Recipients.EMailAddresses := emailDestinatario;
      Email.From.Address              := emailRemetente;//(empresaDB.getEmpresa As TEmpresa).getEmail;
      Email.From.Name                 := nomeRemetente;

      try
//         TIdAttachment.Create(Email.MessageParts, anexo); // usado para anexar arquivos
//         TIdAttachment.Create(Email.MessageParts, arquivoPDF);
         TIdAttachmentFile.Create(Email.MessageParts, anexo); // usado para anexar arquivos
         TIdAttachmentFile.Create(Email.MessageParts, arquivoPDF);
         idSMTP.Connect;
         if idSMTP.Authenticate then
         begin
            idSMTP.Send(Email);
            result := true;
            idSMTP.Disconnect;
         end;
      except
         raise;
         idSMTP.Disconnect;
         result := false;
      end;

   finally
      Email.Free;
      idSMTP.Free;
   end;
end;

//enviar email usando ACBr
function EnviarEmailACBr(porta, host, usuario, senha, assunto, emailRemetente, nomeRemetente, emailDestinatario, nomeDestinatario, anexo: string; corpo: TStringList): boolean;
var
   ACBrMail: TACBrMail;
begin
   ACBrMail := TACBrMail.Create(nil);

   //Configuracando conexao do email
   ACBrMail.Port     := porta;
   ACBrMail.Host     := host;
   ACBrMail.Username := usuario;
   ACBrMail.Password := senha;
   ACBrMail.IsHTML   := true;
   ACBrMail.Attempts := 3;
   ACBrMail.SetSSL   := true;
   ACBrMail.SetTLS   := true;

   ACBrMail.Clear;
   ACBrMail.FromName := nomeRemetente;
   ACBrMail.Subject := assunto;
   ACBrMail.Body.Assign(corpo);
   ACBrMail.AddAddress(emailDestinatario, nomeDestinatario);
   if anexo <> NULL_STRING then
      ACBrMail.AddAttachment(anexo);
   ACBrMail.Send;
end;

//enviar email ISMotors
function EnviarEmailISMotors(cabecalho, corpo, emailRemetente, nomeRemetente, emailDestinatario, nomeDestinatario, anexo: string): boolean;
var
   idSMTP: TIdSMTP;
   idMsg: TIdMessage;
begin
   result := false;
   idSMTP := TIdSMTP.Create(nil);
   idMsg := TIdMessage.Create(nil);
   try
      idSMTP.Port                     := 25;
      idSMTP.Host                     := 'mail.intechsistemas.com.br';
      idSMTP.Username                 := 'intech@intechsistemas.com.br';
      idSMTP.Password                 := 'desdobro';
      idSMTP.AuthType                 := satDefault; //atLogin;
//      idSMTP.AuthenticationType       := atLogin;
      idMsg.Recipients.EMailAddresses := emailDestinatario;
      idMsg.From.Address              := emailRemetente;//(empresaDB.getEmpresa As TEmpresa).getEmail;
      idMsg.From.Name                 := nomeRemetente;

      idMsg.Subject := cabecalho;
      idMsg.Body.Add(corpo);
      idSMTP.Connect;
      try
         if idSMTP.Authenticate then
            idSMTP.Send(idMsg);
      finally
         idSMTP.Disconnect;
      end;
   finally
      idMsg.Free;
      idSMTP.Free;
   end;
end;


//Atualizar combo mesmo que  seja preenchido manual
procedure CheckEnableCombo(out combo: TOrComboBox);
begin
   with combo do
   begin
      Enabled := Items.Count > 1;
      if Items.Count = 1 then
         ItemIndex := 0
      else
         ItemIndex := -1;
   end;
end;

//Calcular custo medio entre dois valores
function CalcularCustoMedio(valorAnterior, valor, desconto, frete: currency; qtdAnterior, qtd: double; QtdCasasDecimais: integer): currency;
var
   custo1, custo2: currency;
begin
   result := 0;

   custo1 := qtdAnterior * valorAnterior;
   custo2 := qtd * (valor - desconto + frete);

   //result := Round((custo1 + custo2) / (qtdAnterior + qtd));
   result :=  Arredondar(((custo1 + custo2) / (qtdAnterior + qtd)), QtdCasasDecimais);

   //result := valorAnterior + valor / (qtdAnterior + qtd);
end;

//Retorna a posicao da string na lista
function CharToPos(chave: string; stringList: TStrings): integer;
var
   i: integer;
begin
   for i := 0 to stringList.Count -1 do
      if Copy(stringList.Strings[i], 1, 1) = chave then
         result := i;
end;

//Retorna string na lista pela posicao
function PosToChar(pos: integer; stringList: TStrings): string;
begin
    result := Copy(stringList.Strings[pos], 1, 1);
end;

//Desativa o botao sair do form
procedure DesativarBotaoSairDoForm(form: TForm);
var
   hMenuHandle: Integer;
begin
   //Desativar o fechar
   with form do
   begin
      hMenuHandle := GetSystemMenu(Handle, False);
      if (hMenuHandle <> 0) then
         DeleteMenu(hMenuHandle, SC_CLOSE, MF_BYCOMMAND);
   end;
end;

//Verificar se o CFOP é de devolução
function VerificarCFOPDevolucaoCompra(CFOP: integer): boolean;
const
  ListaCFOP: array[0..47] of String = ('1200', '5201', '5202', '5208', '5209', '5210', '5410', '5411', '5412', '5413',
                                       '5503', '5553', '5555', '5556', '5660', '5661', '5662', '5918', '5919', '5921',
                                       '6201', '6202', '6208', '6209', '6210', '6410', '6411', '6412', '6413', '6503',
                                       '6553', '6555', '6556', '6660', '6661', '6662', '6918', '6919', '6921', '7201',
                                       '7202', '7210', '7211', '7553', '7556', '7930', '6949', '5949');
var
   i: integer;
begin
   i := 0;
   result := false;
   while ((not result) and (i <= 47)) do
   begin
      result := ListaCFOP[i] = IntToStr(CFOP);
      inc(i);
   end;
end;

//Verificar se o CFOP é de venda
function VerificarCFOPVenda(CFOP: integer): boolean;
const
  ListaCFOP: array[0..79] of String = ('5101', '5102', '5103', '5104', '5105', '5106', '5109', '5110', '5111', '5112',
                                       '5113', '5114', '5115', '5116', '5117', '5118', '5119', '5120', '5251', '5252',
                                       '5253', '5254', '5255', '5256', '5257', '5258', '5402', '5551', '5651', '5652',
                                       '5653', '5654', '5655', '5656', '6101', '6102', '6103', '6104', '6105', '6106',
                                       '6107', '6108', '6109', '6110', '6111', '6112', '6113', '6114', '6115', '6116',
                                       '6117', '6118', '6119', '6120', '6251', '6252', '6253', '6254', '6255', '6256',
                                       '6257', '6258', '6404', '6551', '6651', '6652', '6653', '6654', '6655', '6656',
                                       '7101', '7102', '7105', '7106', '7127', '7251', '7551', '7651', '7654', '7501');
var
   i: integer;
begin
   i := 0;
   result := false;
   while ((not result) and (i <= 79)) do
   begin
      result := ListaCFOP[i] = IntToStr(CFOP);
      inc(i);
   end;
end;

//Verificar se o CFOP é de remessa de deposito
function VerificarCFOPRemessaDeposito(CFOP: integer): boolean;
const
  ListaCFOP: array[0..5] of String = ('1906', '2906', '5905', '5906', '6905', '6906');
var
   i: integer;
begin
   i := 0;
   result := false;
   while ((not result) and (i <= 5)) do
   begin
      result := ListaCFOP[i] = IntToStr(CFOP);
      inc(i);
   end;
end;

//Verificar se o CFOP é de transferencia
function VerificarCFOPTransferencia(CFOP: integer): boolean;
const
  ListaCFOP: array[0..46] of String = ('5602', '1408', '2408', '2552', '6552', '5552', '1552', '2659', '1659', '1658',
                                       '2658', '5659', '6659', '6658', '5658', '5601', '5153', '6153', '2153', '1153',
                                       '6557', '5557', '1557', '2557', '5409', '6409', '6156', '6152', '5152', '5156',
                                       '6408', '5151', '6151', '5408', '5155', '6155', '5605', '2152', '1152', '2409',
                                       '1409', '1151', '2151', '2154', '1154', '6150', '5949');
var
   i: integer;
begin
   i := 0;
   result := false;
   while ((not result) and (i <= 46)) do
   begin
      result := ListaCFOP[i] = IntToStr(CFOP);
      inc(i);
   end;
end;

//Verificar se o CFOP é de combustivel
function VerificarCFOPCombustivel(CFOP: integer): boolean;
const
  ListaCFOP: array[0..59] of String = ('1651', '1652', '1653', '1658', '1659', '1660', '1661', '1662', '1663', '1664',
                                       '2651', '2652', '2653', '2658', '2659', '2660', '2661', '2662', '2663', '2664',
                                       '3651', '3652', '3653', '5651', '5652', '5653', '5654', '5655', '5656', '5657',
                                       '5658', '5659', '5660', '5661', '5662', '5663', '5664', '5665', '5666', '5667',
                                       '6651', '6652', '6653', '6654', '6655', '6656', '6657', '6658', '6659', '6660',
                                       '6661', '6662', '6663', '6664', '6665', '6666', '6667', '7651', '7654', '7667');
var
   i: integer;
begin
   i := 0;
   result := false;
   while ((not result) and (i <= 59)) do
   begin
      result := ListaCFOP[i] = IntToStr(CFOP);
      inc(i);
   end;
end;

//Verificar se o CFOP Conserto ou reparo
function VerificarCFOPConsertoReparo(CFOP: integer): boolean;
const
  ListaCFOP: array[0..5] of String = ('5915', '5916', '6915', '6916', '5912', '5913');
var
   i: integer;
begin
   i := 0;
   result := false;
   while ((not result) and (i <= 5)) do
   begin
      result := ListaCFOP[i] = IntToStr(CFOP);
      inc(i);
   end;
end;

function VerificarCFOPBaixaEstoque(CFOP: integer): boolean;
const
  ListaCFOP: array[0..1] of String = ('5927', '6927');
var
   i: integer;
begin
   i := 0;
   result := false;
   while ((not result) and (i <= 1)) do
   begin
      result := ListaCFOP[i] = IntToStr(CFOP);
      inc(i);
   end;
end;

//Verificar se o diretorio esta com o ultimo caracter
function VerificarAddUltimoDiretorio(diretorio, ultimoCaracter: String): String;
begin
   diretorio := StringReplace(diretorio, '"', '', [rfReplaceAll]);

   if Copy(diretorio, Length(diretorio), 1) <> ultimoCaracter then
      result := diretorio + ultimoCaracter;
end;

//Transformar valor em porcentagem
function TransformarValorEmPorcentagem(valorTotal, valorItem: currency): double;
begin
   if (valorTotal > 0) then
      result := (valorItem * 100 / valorTotal)
   else
      result := 0;
end;

//Verificar se o numero esta na Grid
function NumeroConstaNaGrid(grid: TStringGrid; numero: string; coluna: integer = 0): boolean;
var
   i: integer;
begin
   result := false;
   for i := 1 to grid.RowCount do
      if not result then
         result := (Trim(grid.Cells[coluna, i]) = Trim(numero));
end;

//Verificar se uma id ou chave esta na Grid
function ChaveContaNaGrid(grid: TStringGrid; chave: string; coluna: integer = 0): boolean;
var
   i: integer;
begin
   result := false;
   for i := 1 to grid.RowCount do
      if not result then
         result := (Trim(ChaveEsquerda(grid.Cells[coluna, i])) = Trim(chave));
end;

//Verificar se a string esta na Grid
function StringConstaNaGrid(grid: TStringGrid; chave: string; col: integer): integer;
var
   i: integer;
begin
   result := -1;
   for i := 1 to grid.RowCount do
      if (result = -1) and (pos(Trim(UPPERCASE(chave)), Trim(UPPERCASE(grid.Cells[col, i]))) <> 0) then
         result := i;
end;

//Pega a conteudo da primeira coluna da grid
function  extrairChavePosGrid(grid: TStringGrid; col: integer): String;
begin
   result := Trim(grid.Cells[col, grid.Row]);
end;

//Validar codigo de barra
function ValidarCodigoBarra(vEan: String): Boolean;
var
   Temp1, Temp2, Digito: Integer;
   Temp3, Temp4: String;
begin
   Result := False;
   Temp2 := 0; Temp3 := '';

   if ((Length(vEan) <> 8) and (Length(vEan) <> 12) and
       (Length(vEan) <> 13) and (Length(vEan) <> 18)) then
      Exit;
   Temp4  := '31313131313131313';
   Temp4  := Copy(Temp4,(Length(Temp4) - Length(vEan)), Length(vEan) -1);
   Digito := StrToInt(Copy(vEan, Length(vEan), 1));
   Temp3  := Copy(vEan,1, Length(vEan) -1);
   for Temp1 := 1 to Length(Temp3) do
      Temp2 := Temp2 + StrToInt(Temp3[Temp1]) * StrToInt(Temp4[Temp1]);

   Temp2 := 10 - Round(Frac(Temp2/10)*10);
   if Temp2 = 10 then
      Temp2 := 0;
   Result := (Temp2 = Digito);
end;

//Habilitar ou Desabilitar checkBoxs
procedure HabilitarDesabilitarCheckBoxs(component: TComponent; habilitar: boolean);
var
   i: integer;
begin
   with component do
      for i := 0 to (ComponentCount - 1) do
         if Components[i] is TCheckBox then
            TCheckBox(Components[i]).Enabled := habilitar;
end;

//Truncar casas ECF
function TruncTo(const valor: Double; decimal: integer): Double;
var
  S: string;
  P: integer;
begin
  S := FloatToStr(valor);
  P := Pos(FormatSettings.DecimalSeparator, S);
  if P > 0 then
    S := Copy(S, 1, P-1) + FormatSettings.DecimalSeparator + Copy(S, P+1, decimal);
  Result := StrToFloat(S);
end;

//Trunca valor NFC-e
function TruncaValor(pValor:Double; Decimais:Integer):Currency;
var i, c :integer;
    Valor, aux : String;
    aDec : Boolean;
begin
  c := -1;
  aux := '';
  aDec := false;
  Result := 0;
  Valor := FloatToStr(pValor);
  for i := 1 to length(Valor) do
  begin
    if (copy(Valor,i,1) = ',') or (copy(Valor,i,1) = '.') then
       aDec := true;
    if c < Decimais then
       aux := aux + copy(Valor,i,1);
    if aDec then
       Inc(c);
  end;
  Result := StrToFloat(aux);
end;

//Diferenca entre duas datas
Function calculaTempo(data1 : TDateTime; data2 : TDateTime) : String;
var
   valor, horas, minutos, segundos : Integer;
begin
   valor    := (SecondsBetween(data1, data2));
   horas    := Trunc(valor div 3600);
   minutos  := Trunc(valor div 60 - horas * 60);
   segundos := Trunc((valor - (horas * 3600 + minutos * 60)) + 1);
   if segundos = 60 then
   begin
      inc(minutos);
      segundos := 0;
   end;
   Result := Format('%0.2d:%0.2d:%0.2d', [horas, minutos, segundos]);
end;

//Diferneca entre meses
Function calculaTempoMes(data1 : TDateTime; data2 : TDateTime) : Integer;
begin
   result := MonthsBetween(data1, data2);
   if (result = 0) then
      result := 1;
end;


//Formatar agencia conta de banco
function formatarAgenciaConta(texto: string): String;
begin
   texto := StringReplace(texto, '-', '', [rfReplaceAll]);
   texto := (Copy(texto, 1, Length(texto) -1) + '-' + Copy(texto, Length(texto), 1));
   result := texto;
end;

//Validar codigo GTIN
function ValidarGTIN(GTIN: String): Boolean;
var
   soma: integer;
   DV  : integer;
begin
   result := false;
   try
      if (GTIN <> NULL_STRING) and (Length(strNumeros(GTIN)) in [8, 12, 13, 14])then
      begin
         soma := 0;
         DV   := 0;
         GTIN := PadR(GTIN, '0', 18);

         soma := soma + (StrtoInt(Copy(GTIN, 00, 1)) * 3);
         soma := soma + (StrtoInt(Copy(GTIN, 01, 1)) * 1);
         soma := soma + (StrtoInt(Copy(GTIN, 02, 1)) * 3);
         soma := soma + (StrtoInt(Copy(GTIN, 03, 1)) * 1);
         soma := soma + (StrtoInt(Copy(GTIN, 04, 1)) * 3);
         soma := soma + (StrtoInt(Copy(GTIN, 05, 1)) * 1);
         soma := soma + (StrtoInt(Copy(GTIN, 06, 1)) * 3);
         soma := soma + (StrtoInt(Copy(GTIN, 07, 1)) * 1);
         soma := soma + (StrtoInt(Copy(GTIN, 08, 1)) * 3);
         soma := soma + (StrtoInt(Copy(GTIN, 09, 1)) * 1);
         soma := soma + (StrtoInt(Copy(GTIN, 10, 1)) * 3);
         soma := soma + (StrtoInt(Copy(GTIN, 11, 1)) * 1);
         soma := soma + (StrtoInt(Copy(GTIN, 12, 1)) * 3);
         soma := soma + (StrtoInt(Copy(GTIN, 13, 1)) * 1);
         soma := soma + (StrtoInt(Copy(GTIN, 14, 1)) * 3);
         soma := soma + (StrtoInt(Copy(GTIN, 15, 1)) * 1);
         soma := soma + (StrtoInt(Copy(GTIN, 16, 1)) * 3);

         DV := Trunc(10 - (soma / 10));

         if (DV = 10) then
            DV := 0;
         if (Copy(GTIN, 17, 1) = IntToStr(DV)) then
            result := true;
      end;
   except
      result := false;
   end;
end;

{var
  DigOriginal, DigCalculado, Codigo: String;

  function CalcularDV(ACodigoGTIN: String): String;
  var
    Dig, I, DV: Integer;
  begin
    DV := 0;
    Result := '';

    // adicionar os zeros a esquerda, se não fizer isso o cálculo não bate
    // limite = tamanho maior codigo (gtin14) - 1 (digito)
    ACodigoGTIN := PadR(ACodigoGTIN, '0', 13);

    for I := Length(ACodigoGTIN) downto 1 do
    begin
      Dig := StrToInt(ACodigoGTIN[I]);
      DV  := DV + (Dig * IfThen(odd(I), 3, 1));
    end;

    DV := (Ceil(DV / 10) * 10) - DV ;
    Result := IntToStr(DV);
  end;

begin
   result := false;
   if not(Length(strNumeros(codigoGTIN)) in [8, 12, 13, 14]) then
      result := false
   else
   begin
      Codigo       := Copy(codigoGTIN, 1, Length(codigoGTIN) - 1);
      DigOriginal  := codigoGTIN[Length(codigoGTIN)];
      DigCalculado := CalcularDV(Codigo);

      result := (DigOriginal = DigCalculado);
   end;
end;}

//Função para criptografar e descriptografar string's
function Codifica(Action, Src: String): String;
Label Fim;
var
  KeyLen : Integer;
  KeyPos : Integer;
  OffSet : Integer;
  Dest, Key : String;
  SrcPos : Integer;
  SrcAsc : Integer;
  TmpSrcAsc : Integer;
  Range : Integer;
begin
   try
     if (Src = '') Then
     begin
       Result:= '';
       Goto Fim;
     end;
     Key := 'YUQL23KL23DF90WI5E1JAS467NMCXXL6JAOAUWWMCL0AOMM4A4VZYW9KHJUI2347EJHJKDF3424SKL K3LAKDJSL9RTIKJ';
     Dest := '';
     KeyLen := Length(Key);
     KeyPos := 0;
     SrcPos := 0;
     SrcAsc := 0;
     Range := 256;
     if (Action = UpperCase('C')) then
     begin
       Randomize;
       OffSet := Random(Range);
       Dest := Format('%1.2x',[OffSet]);
       for SrcPos := 1 to Length(Src) do
       begin
         Application.ProcessMessages;
         SrcAsc := (Ord(Src[SrcPos]) + OffSet) Mod 255;
         if KeyPos < KeyLen then KeyPos := KeyPos + 1 else KeyPos := 1;
         SrcAsc := SrcAsc Xor Ord(Key[KeyPos]);
         Dest := Dest + Format('%1.2x',[SrcAsc]);
         OffSet := SrcAsc;
       end;
     end
     Else if (Action = UpperCase('D')) then
     begin
       OffSet := StrToInt('$'+ copy(Src,1,2));
       SrcPos := 3;
     repeat
       SrcAsc := StrToInt('$'+ copy(Src,SrcPos,2));
       if (KeyPos < KeyLen) Then KeyPos := KeyPos + 1 else KeyPos := 1;
       TmpSrcAsc := SrcAsc Xor Ord(Key[KeyPos]);
       if TmpSrcAsc <= OffSet then TmpSrcAsc := 255 + TmpSrcAsc - OffSet
       else TmpSrcAsc := TmpSrcAsc - OffSet;
       Dest := Dest + Chr(TmpSrcAsc);
       OffSet := SrcAsc;
       SrcPos := SrcPos + 2;
     until (SrcPos >= Length(Src));
     end;
     Result:= Dest;
     Fim:
   except
    Src := '';
    Result:= '';
   end;
end;

//Formatar float para PAF
function FormataFloat(Tipo:String; Valor: Extended): string;
var
  i:integer;
  Mascara:String;
begin
  Mascara := '0.';

  if Tipo = 'Q' then
  begin
    for i := 1 to 3 do
      Mascara := Mascara + '0';
  end
  else if Tipo = 'V' then
  begin
    for i := 1 to 2 do
      Mascara := Mascara + '0';
  end;

  Result := FormatFloat(Mascara, Valor);
end;

function RemoveLetrasInicioFimTexto(texto: String): String;
var
   i      : integer;
begin
   result := NULL_STRING;
   for i := 1 to Length(texto) do
   begin
      if texto[i] in ['0'..'9'] then
         result := result + texto[i]
      else if texto[i] = '.' Then
         result := result + texto[i]
      else if texto[i] = ',' Then
         result := result + texto[i];
   end;
end;

//Função que remove mensagem do PALM
function RemoveMensagemPalm(texto: String): String;
var
   i      : integer;
   iniciou,
   processa,
   removePonto: Boolean;
begin
   iniciou  := False;
   processa := False;
   result   := NULL_STRING;
   removePonto := False;
   for i := 1 to Length(texto) do
   begin
      if not processa Then
         result := result + texto[i];

      if result = 'PDA' Then
      begin
         result   := NULL_STRING;
         processa := True;
      end;

      if processa Then
      begin
         if (texto[i] = '.') Then
            iniciou := True;

         if iniciou Then
         begin
            if ((texto[i] = '.') And (removePonto = False)) Then
               removePonto := True
            else
               result := result + texto[i];
         end;
      end;
   end;
   result := RemoveEspacoInicioFimTexto(result);
end;


function RemoveEspacoInicioFimTexto(texto: String): String;
var
   tamanho: integer;
   achou  : boolean;
begin
   achou   := False;

   // verificando a parte inicial do texto.
   tamanho := Length(texto);

   if Copy(texto, 1, 1) = ' ' then
      achou := True;

   while achou do
   begin
      texto := Copy(texto, 2, tamanho);

      if Copy(texto, 1, 1) = ' ' then
         achou := True
      else
         achou := False;
   end;


   // verificando a parte final do texto.
   tamanho := Length(texto);
   if Copy(texto, tamanho, 1) = ' ' then
      achou := True;


   while achou do
   begin
      tamanho := Tamanho - 1;

      texto := Copy(texto, 1, tamanho);

      if Copy(texto, tamanho, 1) = ' ' then
         achou := True
      else
         achou := False;
   end;
   result := texto;
end;

//Pegar e tratar valor de TAG
function TagToInt(No: IXMLNode; nome: String): integer;
begin
   try
      result := No.ChildValues[nome];
   except
      result := 0;
   end;
end;

function TagToStr(No: IXMLNode; nome: String): String;
begin
   try
      result := No.ChildValues[nome];
   except
      result := NULL_STRING;
   end;
end;

function TagToCurr(No: IXMLNode; nome: String): extended;
var
   conteudo: String;
begin
   try
      conteudo := No.ChildValues[nome];
      //conteudo := StringReplace(conteudo, '.', ',', [rfReplaceAll]);
      result := StrToFloatDef(conteudo, 10.50);
   except
      result := 0;
   end;
end;

function TagToDate(No: IXMLNode; nome: String): TDateTime;
var
   formato: TFormatSettings;
begin
   GetLocaleFormatSettings(LOCALE_SYSTEM_DEFAULT, formato);
   try
      //result := StrToDate(No.ChildValues[nome], formato);
      result := StrToDateDef(No.ChildValues[nome], Now);
   except
      result := Now;
   end;
end;

function FormatarCurrency(valor: currency; qtdCasas: integer): String;
var
   formato: string;
begin
   formato := '%15.' + IntToStr(qtdCasas) + 'n';
   result := Format(formato, [valor]);
   result := TRIM(StringReplace(result, '.', '', [rfReplaceAll]));
   result := TRIM(StringReplace(result, ',', '.', [rfReplaceAll]));
end;

//Salvar arquivo txt
function SaveTXTDocument(nameArq, texto: string): String;
var
   arq: TextFile;
begin
   result := '';
   if (Trim(texto) <> '') then
   begin
      assignFile(arq, 'C:\' + nameArq);
      rewrite(arq);
      Writeln(arq, Trim(texto));
      closeFile(arq);

      result := 'C:\' + nameArq;
   end;
end;

//Gravar log de sistema
procedure AtualizarLog(nameArq, texto: string);
var
   arq: TextFile;
begin
   try
      if nameArq = NULL_STRING then
         nameArq := GetApplicationPath + 'intechLog' + FormatDateTime('yyyymm', Now) + '.log';

      texto := FormatDateTime('dd/mm/yyyy HH:MM:SS', Now) + ': '+ texto;

      Assign(arq, nameArq);
      if FileExists(nameArq) then
         Append(arq)
      else
         Rewrite(arq);
      WriteLn(arq, texto);
      CloseFile(arq);
   except

   end;
end;

//Montar arquivo BAT
procedure MontarArqBAT(Arquivo, comando: string);
var
   arq: TextFile;
begin
   AssignFile(arq, Arquivo);
   Rewrite(arq);
   Writeln(arq, comando);
   CloseFile(arq);
end;

//Excutar comando DOS
function ExecutarArqBAT(comando: string): boolean;
var
   StartupInfo: TStartupInfo;
   ProcessInformation: TProcessInformation;
   rc: Boolean;
begin
   FillChar(StartupInfo, SizeOf(StartupInfo), #0);
   with StartupInfo do
      cb := SizeOf(StartupInfo);
   rc := CreateProcess(nil, PChar(comando), nil, nil, false, NORMAL_PRIORITY_CLASS, nil, nil, StartupInfo, ProcessInformation);
   if rc then
   begin
      WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
      result := true;
   end
   else
   begin
      raise Exception.Create(comando + #13 + ' não encontrado neste computador.');
      result := false;
   end;
end;

//Funcao que retorna o dia da semana
function DiaSemana(Data:TDateTime): String;
var
   NoDia : Integer;
   DiaDaSemana : array [1..7] of String[13];
begin
   { Dias da Semana }
   DiaDasemana [1]:= 'Domingo';
   DiaDasemana [2]:= 'Segunda-feira';
   DiaDasemana [3]:= 'Terça-feira';
   DiaDasemana [4]:= 'Quarta-feira';
   DiaDasemana [5]:= 'Quinta-feira';
   DiaDasemana [6]:= 'Sexta-feira';
   DiaDasemana [7]:= 'Sábado';
   
   NoDia     := DayOfWeek(Data);
   DiaSemana := DiaDasemana[NoDia];
end;

//Funcao que retorna a quantidade de dias uteis entre duas datas
function DiasUteis(de, ate: TDateTime): integer;
var
   dia: integer;
begin
   Result := 0;
   if de < ate then
   begin
      repeat
         dia := DayOfWeek(de);
         if (dia >= 2) and (dia <= 6) then
            Inc(Result);
         de := IncDay(de);
      until de > ate;
   end;
end;

//Converter data
function ConverterData(data: String): TDateTime;
var
  dataFormatada : string;
begin
   try
      dataFormatada := copy(data, 9, 2) + '/' + copy(data, 6, 2) + '/' + copy(data, 1, 4);
      result := StrToDateTime(dataFormatada);
   except

   end;
end;

//Formatar chave de acesso NFe
function FormatarChaveAcesso(chave: String): String;
begin
   result := Copy(chave, 1, 4) + '   ';
   result := result + Copy(chave, 5, 4)  + '   ';
   result := result + Copy(chave, 9, 4)  + '   ';
   result := result + Copy(chave, 13, 4) + '   ';
   result := result + Copy(chave, 17, 4) + '   ';
   result := result + Copy(chave, 21, 4) + '   ';
   result := result + Copy(chave, 25, 4) + '   ';
   result := result + Copy(chave, 29, 4) + '   ';
   result := result + Copy(chave, 33, 4) + '   ';
   result := result + Copy(chave, 37, 4) + '   ';
   result := result + Copy(chave, 41, 4);
end;

//Verificar se um IP da rede esta acessivel
function PingIp(host: String; timeOut: integer = 500): Boolean;
var
   IdICMPClient: TIdICMPClient;
begin
   try
      IdICMPClient := TIdICMPClient.Create( nil );
      IdICMPClient.Host := host;
      IdICMPClient.ReceiveTimeout := timeOut;
      IdICMPClient.Ping;

      result := ( IdICMPClient.ReplyStatus.BytesReceived > 0 );
   finally
      IdICMPClient.Free;
   end
end;

function ServerOnline(URL: String): boolean;
begin
   URL := StringReplace(URL, 'http://', '', [rfReplaceAll]);

   result := getIpHost(URL) <> '';
end;

//Pega o host de um IP
Function GetHostNameIP(strIPAddress : String) : String;
Var
   strHost : String ;
   pszIPAddress : PAnsiChar;
   pReturnedHostEnt : PHostEnt;
   InternetAddr : u_long;
   GInitData : TWSADATA;
Begin
   strHost := '';
   If WSAStartup($101, GInitData) = 0 then
   Begin
      pszIPAddress := AnsiStrAlloc( Length( strIPAddress ) + 1 );
      StrPCopy( pszIPAddress, strIPAddress );
      InternetAddr := Inet_Addr(pszIPAddress);
      StrDispose( pszIPAddress );
      pReturnedHostEnt := GetHostByAddr( PChar(@InternetAddr),4, PF_INET );
      try
         strHost := pReturnedHostEnt^.h_name;
         WSACleanup;
         Result := strHost
      except
         Result := 'Host inválido ou não encontrado';
      end;
   end;
end;

//Pega o IP de um host
Function GetIPHost(WebHostName:string):string;
var
   WSAData: TWSAData;
   HostEnt: PHostEnt;
begin
   WSAStartup(2, WSAData);
   HostEnt := gethostbyname(PAnsiChar(WebHostName));
   with HostEnt^ do
   begin
      try
         Result := Format('%d.%d.%d.%d',
            [Byte(h_addr^[0]),Byte(h_addr^[1]),
            Byte(h_addr^[2]),Byte(h_addr^[3])]);
      except
         Result := '';
      end;
   end;
   WSACleanup;
end;

//Conversores DiaSemana
function IntegerToDiaSemana(dia: integer): TDiaSemana;
begin
   case dia of
      0: result := dsIndefinido;
      1: result := dsDomingo;
      2: result := dsSegunda;
      3: result := dsTerca;
      4: result := dsQuarta;
      5: result := dsQuinta;
      6: result := dsSexta;
      7: result := dsSabado;
   end;
end;

function DiaSemanaToInteger(dia: TDiaSemana): integer;
begin
   case dia of
      dsIndefinido: result := 0;
      dsDomingo:    result := 1;
      dsSegunda:    result := 2;
      dsTerca:      result := 3;
      dsQuarta:     result := 4;
      dsQuinta:     result := 5;
      dsSexta:      result := 6;
      dsSabado:     result := 7;
   end;
end;

function DiaSemanaToStr(dia: TDiaSemana): String;
begin
   case DiaSemanaToInteger(dia) of
      0: result := 'Indefinido';
      1: result := 'Domingo';
      2: result := 'Segunda-feira';
      3: result := 'Terça-feira';
      4: result := 'Quarta-feira';
      5: result := 'Quinta-feira';
      6: result := 'Sexta-feira';
      7: result := 'Sábado';
   end;
end;

//Converter data-Hora
//A String deve estar no formato: DD/MM/AA HH:MM:SS.
function ConverterDataHora(data: String; hora: String): TDateTime;
var
    DataHora: TDateTime;
begin
    DataHora := StrToDateTime(data + '' + hora);
    result := DataHora;
end;

function MontarDataHora(data: String; hora: String; HorasASomar: Double): TDateTime;
const
     UmaHora = 1/24;
var
     Data1,Data2  : TDateTime;
     Contador,
     HoraAtual    : Integer;
     HoraCalculada: String;
begin
   contador      := 1;
   
   Data1 := ConverterDataHora(data, hora); // convertendo o dia.
   while (contador <= HorasASomar) do
   begin
      Data1    := Data1 + UmaHora; // uma hora a mais
      contador := contador + 1;
   end;



   //se a hora for maior que 18 horas vai para 7 do dia seguinte.
   HoraCalculada := FormatDateTime('HH:MM:SS', Data1);
   horaAtual     := StrToInt(copy(HoraCalculada, 1, 2));
   if horaAtual > 17 Then
   begin
      while HoraAtual <= 23 do
      begin
         Data1     := Data1 + UmaHora; // uma hora a mais
         HoraAtual := HoraAtual + 1;
      end;
   end;

   //se for menor que 7 horas vai para sete do mesmo dia.
   HoraCalculada := FormatDateTime('HH:MM:SS', Data1);
   horaAtual     := StrToInt(copy(HoraCalculada, 1, 2));
   if HoraAtual < 7 Then
   begin
      while HoraAtual <= 6 do
      begin
         Data1     := Data1 + UmaHora; // uma hora a mais
         HoraAtual := HoraAtual + 1;
      end;
   end;

   //Se cair no sabado, joga para a segunda
   if DiaSemana(data1)= 'Sábado' Then
      data1 := data1 + 2;

   //se cair no domingo joga para a segunda
   if DiaSemana(data1)= 'Domingo' Then
      data1 := data1 + 1;

   HoraCalculada := FormatDateTime('HH:MM:SS', Data1);
   result := data1;
end;

//Conversores StatusCT-e
function StrToStatusCTe(status: String): TStatusCTe;
begin
   if status = 'D' then
      result := stCTeDigitada
   else if status = 'F' then
      result := stCTeFinalizada
   else if status = 'C' then
      result := stCTeCancelada
   else if status = 'P' then
      result := stCTeProcessamento;
end;

function StatusCTeToStr(status: TStatusCTe): String;
begin
   case status of
      stCTeDigitada:       result := 'D';
      stCTeFinalizada:     result := 'F';
      stCTeCancelada:      result := 'C';
      stCTeProcessamento:  result := 'P';
   end;
end;

//Conversores StatusMDF-e
function StrToStatusMDFe(status: String): TStatusMDFe;
begin
   if status = 'D' then
      result := stMDFeDigitada
   else if status = 'F' then
      result := stMDFeFinalizada
   else if status = 'C' then
      result := stMDFeCancelada
   else if status = 'P' then
      result := stMDFeProcessamento
   else if status = 'E' then
      result := stMDFeEncerrada;
end;

function StatusMDFeToStr(status: TStatusMDFe): String;
begin
   case status of
      stMDFeDigitada:      result := 'D';
      stMDFeFinalizada:    result := 'F';
      stMDFeCancelada:     result := 'C';
      stMDFeProcessamento: result := 'P';
   end;
end;

//Conversores StatusDF-e
function StrToStatusDFe(status: String): TStatusDFe;
begin
   if status = 'D' then
      result := stDFeDigitado
   else if status = 'F' then
      result := stDFeFinalizado
   else if status = 'C' then
      result := stDFeCancelado
   else if status = 'P' then
      result := stDFeProcessamento
   else if status = 'R' then
      result := stDFeRejeitado;
end;

function StatusDFeToStr(status: TStatusDFe): String;
begin
   case status of
      stDFeDigitado:      result := 'D';
      stDFeFinalizado:    result := 'F';
      stDFeCancelado:     result := 'C';
      stDFeProcessamento: result := 'P';
      stDFeRejeitado:     result := 'R';
   end;
end;

   //Conversores StatusGNRE
function StrToStatusGNRE(status: String): TStatusGNRE;
begin
   if status = 'D' then
      result := stGNREDigitada
   else if status = 'F' then
      result := stGNREFinalizada
   else if status = 'C' then
      result := stGNRECancelada
   else if status = 'P' then
      result := stGNREProcessamento
   else if status = 'E' then
      result := stGNREEncerrada;
end;

function StatusGNREToStr(status: TStatusGNRE): String;
begin
   case status of
      stGNREDigitada:      result := 'D';
      stGNREFinalizada:    result := 'F';
      stGNRECancelada:     result := 'C';
      stGNREProcessamento: result := 'P';
      stGNREEncerrada:     result := 'E';
   end;
end;

//Ativar quilhotina de impressora nao fiscal
function ativarGuilhotina: String;
begin
   result := chr(ord(strtoint('$1D')))+chr(ord(strtoint( '$56')))+chr(ord(strtoint('$01')));
end;

//Ativar quilhotina de impressora nao fiscal
function ativarGuilhotinaElginI9: String;
begin
   result := chr(ord(strtoint('$29')))+chr(ord(strtoint( '$86')))+chr(ord(strtoint('$0')));
end;

//Ativar quilhotina de impressora nao fiscal
function ativarGuilhotinaEpsonTmT20: String;
begin
   //result := chr(ord(strtoint('$29')))+chr(ord(strtoint( '$86')))+chr(ord(strtoint('$1')));
   //result := chr(ord(strtoint('$27')))+chr(ord(strtoint( '$10')))+chr(ord(strtoint('$5')));
   result := #29 + #86 + #1;
end;

function CortaPapel(const Epson:Boolean; Porta:String):Boolean;
var
   Corte : TStringList ;
begin
   try
      Corte := TStringList.Create;
      if Epson then
         Corte.Add(chr(ord(strtoint('29')))+chr(ord(strtoint( '+86')))+chr(ord(strtoint('+01'))))
      else
         Corte.Add(chr(ord(strtoint('$1D')))+chr(ord(strtoint( '$56')))+chr(ord(strtoint('$01'))));
      Corte.SaveToFile(Porta);
   finally
      Corte.Free;
   end;
end;

//Diz se o CFOP é de devoluçao saída
function EhCFOPDevolucaoSaida(cfop: string): boolean;
begin
   result := False;
   try
      if ((cfop = '5202') Or (cfop = '5411') Or (cfop = '6202') Or (cfop = '6411')) Then
         result := True;
   except
      Application.MessageBox('CFOP não informado.', MT_ALERTA, MB_OK + MB_ICONWARNING);
   end;
end;

//Diz se o CFOP é de devoluçao entrada
function EhCFOPDevolucaoEntrada(cfop: string): boolean;
begin
   result := False;
   try
      if ((cfop = '1411') Or (cfop = '2411') or (cfop = '1202') or (cfop = '2202') or (cfop = '1201') or (cfop = '2201')) Then
         result := True;
   except
      Application.MessageBox('CFOP não informado.', MT_ALERTA, MB_OK + MB_ICONWARNING);
   end;
end;

//Diz se o PIS-COFINS é de suspensão
function EhSuspensaoPISCofins(piscofins: string): boolean;
begin
   result := False;
   try
      if ((piscofins = '08') or (piscofins = '49') or (piscofins = '09')) Then
         result := True;
   except
      Application.MessageBox('PIS-COFINS não informado.', MT_ALERTA, MB_OK + MB_ICONWARNING);
   end;
end;

function EhSuspensaoPISCofinsEntrada(piscofins: string): boolean;
begin
   result := False;
   try
      if (piscofins = '98') Then
         result := True;
   except
      Application.MessageBox('PIS-COFINS não informado.', MT_ALERTA, MB_OK + MB_ICONWARNING);
   end;
end;

//Retorna o codigo do Estado pela Sigla
function UFNFe(siglaEstado: string): integer;
begin
   result := 0;
   if siglaEstado = 'RO' then
      result := 11
   else if siglaEstado = 'AC' then
      result := 12
   else if siglaEstado = 'AM' then
      result := 13
   else if siglaEstado = 'RR' then
      result := 14
   else if siglaEstado = 'PA' then
      result := 15
   else if siglaEstado = 'AP' then
      result := 16
   else if siglaEstado = 'TO' then
      result := 17
   else if siglaEstado = 'MA' then
      result := 21
   else if siglaEstado = 'PI' then
      result := 22
   else if siglaEstado = 'CE' then
      result := 23
   else if siglaEstado = 'RN' then
      result := 24
   else if siglaEstado = 'PB' then
      result := 25
   else if siglaEstado = 'PE' then
      result := 26
   else if siglaEstado = 'AL' then
      result := 27
   else if siglaEstado = 'SE' then
      result := 28
   else if siglaEstado = 'BA' then
      result := 29
   else if siglaEstado = 'MG' then
      result := 31
   else if siglaEstado = 'ES' then
      result := 32
   else if siglaEstado = 'RJ' then
      result := 33
   else if siglaEstado = 'SP' then
      result := 35
   else if siglaEstado = 'PR' then
      result := 41
   else if siglaEstado = 'SC' then
      result := 42
   else if siglaEstado = 'RS' then
      result := 43
   else if siglaEstado = 'MS' then
      result := 50
   else if siglaEstado = 'MT' then
      result := 51
   else if siglaEstado = 'GO' then
      result := 52
   else if siglaEstado = 'DF' then
      result := 53;
end;

function ExtrairUFNFeChave(chave: string): integer;
begin
   //if (Length(chave) = 44) then
      result := StrToInt(Copy(chave, 1, 2));
   //result := -1;
end;

//Retorna os principais dados de uma NF-e
procedure DesmembrarChaveNFe(chaveAcesso: string; out uf, cnpjEmitente, modelo, serie, numeroNFe: string);
var
   E: Exception;
begin
   if Length(chaveAcesso) = 44 then
   begin
      uf              := copy(chaveAcesso, 1, 2);
      cnpjEmitente    := copy(chaveAcesso, 7, 14);
      modelo          := copy(chaveAcesso, 22, 2);
      serie           := copy(chaveAcesso, 23, 3);
      numeroNfe       := copy(chaveAcesso, 28, 7);
   end else
      Application.ShowException(E.Create('Erro do sistema! Chave da NF-e inválida!'));
end;

function ToUpper(Text: String): String;
var
   Ind: Integer;

const
   LW = 'áâãàéêíóôõúüûçñ';
   UP = 'ÁÂÃÀÉÊÍÓÔÕÚÜÛÇÑ';
begin
   Result := NULL_STRING;

   for Ind := 1 to Length(Text) do
      if Pos(Copy(Text, Ind, 1), LW) > 0 then
         Result := Result + Copy(UP, Pos(Copy(Text, Ind, 1), LW), 1)
      else
         Result := Result + UpperCase(Copy(Text, Ind, 1));
end;

function ToLower(Text: String): String;
var
   Ind: Integer;
const
   LW = 'áâãàéêíóôõúüûçñ';
   UP = 'ÁÂÃÀÉÊÍÓÔÕÚÜÛÇÑ';
begin
   Result := NULL_STRING;

   for Ind := 1 to Length(Text) do
      if Pos(Copy(Text, Ind, 1), UP) > 0 then
         Result := Result + Copy(LW, Pos(Copy(Text, Ind, 1), UP), 1)
      else
         Result := Result + LowerCase(Copy(Text, Ind, 1));
end;

//Funcao que converte String em Sexo
function StrToSexo(pos: String): TSexo;
begin
   if pos = 'F' then
      result := Feminino
   else
      result := Masculino;
end;

//Funcao que converte sexo em String
function SexoToStr(tipoSexo: TSexo): String;
begin
   if tipoSexo = Feminino then
      result := 'F'
   else
      result := 'M';
end;

//pedir senha
{function PedirSenhaGeral(permissaoDB: IPermissaoDB; configuracao: TORObject; moduloFinanceiro, moduloFaturamento, manipulandoParcela: boolean;
   frmSenha: TFrmSenha; operacao: String; mensagemPersonalizada: String = MSG_SENHA_ADMINISTRADOR): boolean;
begin
   result := False;

   if not result then
   begin
      if (mensagemPersonalizada = NULL_STRING) or (Application.MessageBox(PChar(mensagemPersonalizada), MT_ALERTA, MB_YESNO + MB_ICONWARNING) = IDYES) then
      begin
         frmSenha.setPermissaoDB(permissaoDB);
         frmSenha.ShowModal;

         permissaoDB.encontrarPorUsuario(frmSenha.cmbUsuario.Text, frmSenha.edtSenha.Text);
         if not Result Then
         begin
            try
               result := UpperCase(frmSenha.getSenha) = UpperCase((configuracao As TConfiguracao).getSenha);
               if not result then
                  Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);

               if Result then
                  permissaoDB.registrarLogLiberacao(operacao, frmSenha.getUsuario);

            finally
               frmSenha.Release;
            end;
         end
         else
         begin
            permissaoDB.registrarLogLiberacao(operacao, dtmData.getConexao.getUsuario);
            frmSenha.Release;
         end;
      end
      else
         frmSenha.Release;
   end
   else
   begin
      permissaoDB.registrarLogLiberacao(operacao, dtmData.getConexao.getUsuario);
      frmSenha.Release;
   end;
end;

//pedir senha do administrador
{function PedirSenhaAdmin(permissaoDB: IPermissaoDB; configuracao: TORObject; moduloFinanceiro, moduloFaturamento, manipulandoParcela: boolean;
                         frmSenha: TFrmSenha; operacao: String; mensagemPersonalizada: String = MSG_SENHA_ADMINISTRADOR): boolean;
begin
   permissaoDB.encontrarPorUsuario(dtmData.getConexao.getUsuario, dtmData.getConexao.getSenha);
   permissaoDB.recuperarUsuario;

   if (manipulandoParcela) and (moduloFinanceiro) then
   begin
      result := (permissaoDB.getPermissao As TPermissao).getManipularParcela;
      if not result then
         Application.MessageBox(MSG_USUARIO_SEM_PERMISSAO, MT_ALERTA, + MB_OK + MB_ICONWARNING);
   end
   else
   begin
      result := (permissaoDB.getPermissao As TPermissao).getLiberarSenhaAdmin;

      if not result then
      begin
         if (mensagemPersonalizada = NULL_STRING) or (Application.MessageBox(PChar(mensagemPersonalizada), MT_ALERTA, MB_YESNO + MB_ICONWARNING) = IDYES) then
         begin
            frmSenha.setPermissaoDB(permissaoDB);
            frmSenha.ShowModal;
            //foi realocado pois o mesmo estava perdendo a estancia.
            permissaoDB.encontrarPorUsuario(frmSenha.cmbUsuario.Text, frmSenha.edtSenha.Text);
            //permissaoDB.encontrarPorUsuario(dtmData.getConexao.getUsuario);
            //permissaoDB.recuperarUsuario;

            result := (permissaoDB.getPermissao As TPermissao).getLiberarSenhaAdmin;

            if not Result Then
            begin
               try
                  if moduloFaturamento then
                  begin
                     if ((permissaoDB.getPermissao As TPermissao).getEhAdminFaturamento) and ((permissaoDB.getPermissao As TPermissao).getSenhaAdmin <> NULL_STRING) then
                     begin
                        result := UpperCase(frmSenha.getSenha) = UpperCase((permissaoDB.getPermissao As TPermissao).getSenhaAdmin);
                        if not result then
                           Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
                     end
                     else
                     begin
                        result := UpperCase(frmSenha.getSenha) = UpperCase((configuracao As TConfiguracao).getSenha);
                        if not result then
                           Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
                     end;
                  end
                  else if moduloFinanceiro then
                  begin
                     if ((permissaoDB.getPermissao As TPermissao).getEhAdminCaixa) and ((permissaoDB.getPermissao As TPermissao).getSenhaAdmin <> NULL_STRING) then
                     begin
                        result := UpperCase(frmSenha.getSenha) = UpperCase((permissaoDB.getPermissao As TPermissao).getSenhaAdmin);
                        if not result then
                           Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
                     end
                     else
                     begin
                        result := UpperCase(frmSenha.getSenha) = UpperCase((configuracao As TConfiguracao).getSenhaAdminCaixa);
                        if not result then
                           Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
                     end;
                  end
                  else
                  begin
                     if ((permissaoDB.getPermissao As TPermissao).getEhAdminSistema) and ((permissaoDB.getPermissao As TPermissao).getSenhaAdmin <> NULL_STRING) then
                     begin
                        result := UpperCase(frmSenha.getSenha) = UpperCase((permissaoDB.getPermissao As TPermissao).getSenhaAdmin);
                        if not result then
                           Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
                     end
                     else
                     begin
                        result := UpperCase(frmSenha.getSenha) = UpperCase((DtmData.getConfiguracao As TConfiguracao).getSenha);
                        if not result then
                           Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
                     end;
                  end;

                  if Result then
                     permissaoDB.registrarLogLiberacao(operacao, frmSenha.getUsuario);

               finally
                  frmSenha.Release;
               end;
            end
            else
            begin
               permissaoDB.registrarLogLiberacao(operacao, dtmData.getConexao.getUsuario);
               frmSenha.Release;
            end;
         end
         else
            frmSenha.Release;
      end
      else
      begin
         permissaoDB.registrarLogLiberacao(operacao, dtmData.getConexao.getUsuario);
         frmSenha.Release;
      end;
   end;
end;

function PedirSenhaAdminUsuario(permissaoDB: IPermissaoDB; configuracao: TORObject; moduloFinanceiro, moduloFaturamento: boolean;
                            frmSenha: TFrmSenha; operacao: String; mensagemPersonalizada: String = MSG_SENHA_ADMINISTRADOR): boolean;
begin
   frmSenha.setPermissaoDB(permissaoDB);
   frmSenha.ShowModal;

   //foi realocado pois o mesmo estava perdendo a estancia.
   //permissaoDB.encontrarPorUsuario(dtmData.getConexao.getUsuario);
   permissaoDB.encontrarPorUsuario(frmSenha.cmbUsuario.Text, frmSenha.edtSenha.Text);
   permissaoDB.recuperarUsuario;

   result := (permissaoDB.getPermissao As TPermissao).getLiberarSenhaAdmin;

   if not result then
   begin
      if (mensagemPersonalizada = NULL_STRING) or (Application.MessageBox(PChar(mensagemPersonalizada), MT_ALERTA, MB_YESNO + MB_ICONWARNING) = IDYES) then
      begin
         try
            if moduloFaturamento then
            begin
               if ((permissaoDB.getPermissao As TPermissao).getEhAdminFaturamento) and ((permissaoDB.getPermissao As TPermissao).getSenhaAdmin <> NULL_STRING) then
               begin
                  result := UpperCase(frmSenha.getSenha) = UpperCase((permissaoDB.getPermissao As TPermissao).getSenhaAdmin);
                  if not result then
                     Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
               end
               else
               begin
                  result := UpperCase(frmSenha.getSenha) = UpperCase((configuracao As TConfiguracao).getSenha);
                  if not result then
                     Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
               end;
            end
            else if moduloFinanceiro then
            begin
               if ((permissaoDB.getPermissao As TPermissao).getEhAdminCaixa) and ((permissaoDB.getPermissao As TPermissao).getSenhaAdmin <> NULL_STRING) then
               begin
                  result := UpperCase(frmSenha.getSenha) = UpperCase((permissaoDB.getPermissao As TPermissao).getSenhaAdmin);
                  if not result then
                     Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
               end
               else
               begin
                  result := UpperCase(frmSenha.getSenha) = UpperCase((configuracao As TConfiguracao).getSenhaAdminCaixa);
                  if not result then
                     Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
               end;
            end
            else
            begin
               if ((permissaoDB.getPermissao As TPermissao).getEhAdminSistema) and ((permissaoDB.getPermissao As TPermissao).getSenhaAdmin <> NULL_STRING) then
               begin
                  result := UpperCase(frmSenha.getSenha) = UpperCase((permissaoDB.getPermissao As TPermissao).getSenhaAdmin);
                  if not result then
                     Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
               end
               else
               begin
                  result := UpperCase(frmSenha.getSenha) = UpperCase((configuracao As TConfiguracao).getSenha);
                  if not result then
                     Application.MessageBox(MSG_SENHA_INVALIDA, MT_ALERTA, + MB_OK + MB_ICONWARNING);
               end;
            end;

            if Result then
               permissaoDB.registrarLogLiberacao(operacao, frmSenha.getUsuario);

         finally
            frmSenha.Release;
         end;
      end
      else
         frmSenha.Release;
   end
   else
   begin
      permissaoDB.registrarLogLiberacao(operacao, frmSenha.getUsuario);
      frmSenha.Release;
   end;
end;
 }

//Tipo do documento fiscal referencia da NF
function IntToTipoNFRef(pos: integer): TTipoNFRef;
begin
   result := refNFe;

   case pos of
      0: result := refNFe;
      1: result := refNF;
      2: result := refNFP;
      3: result := refCTe;
      4: result := refECF;
   end;
end;

function TipoNFRefToInt(tipo: TTipoNFRef): Integer;
begin
   result := 0;
   case tipo of
      refNFe: result := 0;
      refNF : result := 1;
      refNFP: result := 2;
      refCTe: result := 3;
      refECF: result := 4;
   end;
end;

function FormatarValorTruncando(valor: double; qtdCasas: integer; TruncarValor: boolean = false): String;
var
   formato: string;
begin
   if valor > 0 Then
   begin
      if (TruncarValor) then
         valor := TruncTo(valor, 2);

      if qtdCasas <= 4 then
      begin
         formato := '%15.' + IntToStr(qtdCasas) + 'n';
         result := Format(formato, [valor]);
         result := TRIM(StringReplace(result, '.', '', [rfReplaceAll]));
         result := TRIM(StringReplace(result, '.', ',', [rfReplaceAll]));
      end
      else
      begin
         result :=  FormatFloat('0.' + StrZero(0, qtdCasas), valor);
         result := TRIM(StringReplace(result, '.', '', [rfReplaceAll]));
         result := TRIM(StringReplace(result, '.', ',', [rfReplaceAll]));
      end;
   end
   else
   begin
      result :=  FormatFloat('0.00', valor);
      result := TRIM(StringReplace(result, '.', '', [rfReplaceAll]));
      result := TRIM(StringReplace(result, '.', ',', [rfReplaceAll]));
   end;
   result := result;
end;

function FormatarValor(valor: double; qtdCasas: integer; arredondarValor: boolean = false): String;
var
   formato: string;
begin
   if (arredondarValor) then
      valor := Arredondar(valor, 2);

   if qtdCasas <= 4 then
   begin
      formato := '%15.' + IntToStr(qtdCasas) + 'n';
      result := Format(formato, [valor]);
      result := TRIM(StringReplace(result, '.', '', [rfReplaceAll]));
      result := TRIM(StringReplace(result, ',', '.', [rfReplaceAll]));
   end else
   begin
      result :=  FormatFloat('0.' + StrZero(0, qtdCasas), valor);
      result := TRIM(StringReplace(result, '.', '', [rfReplaceAll]));
      result := TRIM(StringReplace(result, ',', '.', [rfReplaceAll]));
   end;
end;

function FormatarValor2(valor: double; qtdCasas: integer): Double;
var
   formato: string;
begin
   result := 0;

   if qtdCasas <= 4 then
   begin
      formato := '%15.' + IntToStr(qtdCasas) + 'n';
      result := StrToValor(Format(formato, [valor]));
   end else
      result := valor;
end;

function RoundNum(Valor:Extended;Decimais:Integer):Extended;
{Quando houver,Arredonda uma possivel terceira casa decimal em uma variável}
var
  I:Integer;
  Multiplicador:Integer;
begin
   Result := 0;

   if (Decimais > 15) then
      Decimais := 15
   else if (Decimais < 0) then
      Decimais := 0;

   Multiplicador := 1;

   for I := 1 to Decimais do
      Multiplicador := Multiplicador * 10;

   Result := round(Valor * Multiplicador) / Multiplicador;
end;

function FormatarFloat(valor: currency; qtdCasas: integer): String;
begin
   result := FormatFloat('##########.##0.00', valor);
end;

function FormatarValorLabel(valor: currency; qtdCasas: integer; labelx: String; monetario: boolean): String;
var
  mascara: String;
begin
  if monetario then
    mascara := '%12.'+ intToStr(qtdCasas) + 'm'
  else
    mascara := '%12.'+ intToStr(qtdCasas) + 'n';

  result := labelx + ' ' + Trim(Format(mascara, [valor]));
end;

function FormatarQuantidade(quantidade: double): String;
begin
   result := Format('%6.4n', [quantidade]);

   result := TRIM(StringReplace(result, '.', '', [rfReplaceAll]));
   result := TRIM(StringReplace(result, ',', '.', [rfReplaceAll]));
end;

function FormatarPorcentagem(porcentagem: double): String;
begin
   result := Format('%5.2n', [porcentagem]);
   result := TRIM(StringReplace(result, '.', '', [rfReplaceAll]));
   result := TRIM(StringReplace(result, ',', '.', [rfReplaceAll]));
end;

function FormatarStrHoraMInuto(text: String): String;
var
   ehNegativo: Boolean;
begin
   ehNegativo := False;
   result := NULL_STRING;

   if Text <> NULL_STRING Then
   begin
      if copy(Text, 1, 1) = '-' Then
      begin
         ehNegativo := True;
         Text := Copy(Text, 2, Length(text));
      end;

      if Length(text) < 4 Then
         text := PadL(Text, '0', 4);

      result := copy(text, 1, (length(text) - 2)) + ':' + Copy(text, (length(text) - 1), 2);

      if ehNegativo Then
         result := '-' + result;
   end;
end;

function RemoverNumero(texto: String): String;
var
   i    : Integer;
begin
   result := NULL_STRING;
   for i := 1 to Length(texto) do
   begin
      if texto[i] in ['A'..'z'] then
         result := result + texto[i]
      else if texto[i] = '' Then
         result := result + texto[i]
      else if texto[i] = ' ' Then
         result := result + texto[i];
   end;
end;

//Funcao que retorna os principais tipos de ocorrencia de boleto
function TipoOcorrenciaBoletoToDescricao(codigo: integer): String;
begin
   result := IntToStr(codigo) + '-SEM REGISTRO';
  case codigo of
     1: Result := '01-Solicitação de Impressão de Títulos Confirmada';
     2: Result := '02-Entrada Confirmada';
     3: Result := '03-Entrada Rejeitada';
     4: Result := '04-Transferência de Carteira/Entrada';
     5: Result := '05-Transferência de Carteira/Baixa';
     6: Result := '06-Liquidação';
     7: Result := '07-Confirmação do Recebimento da Instrução de Desconto';
     8: Result := '08-Confirmação do Recebimento do Cancelamento do Desconto';
     9: Result := '09-Baixa';
    12: Result := '12-Confirmação Recebimento Instrução de Abatimento';
    13: Result := '13-Confirmação Recebimento Instrução de Cancelamento Abatimento';
    14: Result := '14-Confirmação Recebimento Instrução Alteração deVencimento';
    19: Result := '19-Confirmação Recebimento Instrução de Protesto';
    20: Result := '20-Confirmação Recebimento Instrução de Sustação/Cancelamento de Protesto';
    23: Result := '23-Remessa a Cartório';
    24: Result := '24-Retirada de Cartório';
    25: Result := '25-Protestado e Baixado (Baixa por Ter Sido Protestado)';
    26: Result := '26-Instrução Rejeitada';
    27: Result := '27-Confirmação do Pedido de Alteração de Outros Dados';
    28: Result := '28-Débito de Tarifas/Custas';
    30: Result := '30-Alteração de Dados Rejeitada';
    33: Result := '33-Confirmação de Pedido de Alteração de Outros Dados';
    34: Result := '34-Retirado de Cartório e Manutenção em Carteira';
    35: Result := '35-Confirmação de Inclusão Banco de Sacado';
    36: Result := '36-Confirmação de Alteração Banco de Sacado';
    37: Result := '37-Confirmação de Exclusão Banco de Sacado';
    38: Result := '38-Emissão de Bloquetos de Banco de Sacado';
    39: Result := '39-Manutenção de Sacado Rejeitada';
    40: Result := '40-Entrada de Título via Banco de Sacado Rejeitada';
    41: Result := '41-Manutenção de Banco de Sacado Rejeitada';
    44: Result := '44-Estorno de Baixa / Liquidação';
    45: Result := '45-Alteração de Dados';
    46: Result := '46-Convenio encerrado' ;
    47: Result := '47-Título tem valor diverso do informado';
    48: Result := '48-Motivo de baixa inválido para a carteira';
    49: Result := '49-Abatimento a cancelar não consta do título';
    50: Result := '50-Comando incompativel com a carteira';
    51: Result := '51-Codigo do convenente inválido';
    52: Result := '52-Abatimento igual ou maior que o valor do título';
    53: Result := '53-Título já se encontra situação pretendida';
    54: Result := '54-Título fora do prazo admitido para a conta 1';
    55: Result := '55-Novo vencimento fora dos limites da carteira';
    56: Result := '56-Título não pertence ao convenente';
    57: Result := '57-Variação incompativel com a carteira';
    58: Result := '58-Impossivel a transferencia para a carteira indicada';
    59: Result := '59-Título vencido em transferencia para a carteira 51';
    60: Result := '60-Título com prazo superior a 179 dias em transferencia para carteira 51';
    61: Result := '61-Título já foi fichado para protesto';
    62: Result := '62-Alteração da situação de debito inválida para o codigo de responsabilidade';
    63: Result := '63-DV do nosso número inválido' ;
    64: Result := '64-Título não passivel de debito/baixa - situação anormal';
    65: Result := '65-Título com ordem de não protestar-não pode ser encaminhado a cartorio';
    67: Result := '66-Título/carne rejeitado';
    80: Result := '80-Nosso número inválido';
    81: Result := '81-Data para concessão do desconto inválida';
    82: Result := '82-CEP do sacado inválido';
    83: Result := '83-Carteira/variação não localizada no cedente';
    84: Result := '84-Título não localizado na existencia';
    99: Result := '99-Outros motivos';
  end;
end;

//Funcao que retorna o CEST com base no NCM e no CST da mercadoria
//(Código Especificador da Substituição Tributária)
function CalcularCEST(NCM_SH, CST, CESTPROD: String): String;
var
   CEST: TCEST;
begin
   result := NULL_STRING;

   if Length(CST) = 2 then
   begin
      if AnsiContainsText('10, 30, 60, 70, 90', CST) then
      begin
         if (CESTPROD <> NULL_STRING) then
            result := '<CEST>' + CESTPROD + '</CEST>' + #13#10
         else
            result := '<CEST>' + CEST.Calcular(NCM_SH) + '</CEST>' + #13#10;
      end;
   end else if Length(CST) = 3 then
   begin
      if AnsiContainsText('201, 202, 203, 500, 900', CST) then
      begin
         if (CESTPROD <> NULL_STRING) then
            result := '<CEST>' + CESTPROD + '</CEST>' + #13#10
         else
            result := '<CEST>' + CEST.Calcular(NCM_SH) + '</CEST>' + #13#10;
      end;
   end;
end;

Function OrganizaNumeroTelefone(numero: String) : String;
var
   tamanho: Integer;
begin
   result := '(  )    -    ';

   if numero <> NULL_STRING Then
   begin
      tamanho := length(strNumeros(numero));

      result := '(';

      if tamanho = 8 Then
         result := result + 'XX)' + copy(StrNumeros(numero), 1, 4) + '-' + copy(StrNumeros(numero), 5, 4)
      else
         result := result + copy(StrNumeros(numero), 1, 2) + ')' + copy(StrNumeros(numero), 3, 4) + '-' + copy(StrNumeros(numero), 7, 4);
   end;
end;

function DigitoQtd(qtd: double): String;
var
   digito: double;
begin
   digito := (Trunc(qtd) - qtd);
   if (digito = 0) then
      result := Format('%8.0n', [qtd])
   else
      result := Format('%8.3n', [qtd]);
end;

function DigitoValor(Valor: Currency; monetario: boolean = false): String;
var
   digito: Currency;
   dg: String;
begin
   if monetario then
      dg := 'm'
   else
      dg := 'n';

   digito := (Trunc(valor) - valor);
   if (digito = 0) then
   begin
      if monetario then
         result := Format('%8.2' + dg, [valor])
      else
         result := Format('%8.0' + dg, [valor]);
   end else
   begin
      {if (DtmData.getConfiguracao As TConfiguracao).getQtdCasasDecimaisMostrarProduto = 0 Then
         result := Format('%8.0' + dg, [valor])
      else if (DtmData.getConfiguracao As TConfiguracao).getQtdCasasDecimaisMostrarProduto = 1 Then
         result := Format('%8.1' + dg, [valor])
      else if (DtmData.getConfiguracao As TConfiguracao).getQtdCasasDecimaisMostrarProduto = 2 Then
         result := Format('%8.2' + dg, [valor])
      else if (DtmData.getConfiguracao As TConfiguracao).getQtdCasasDecimaisMostrarProduto = 3 Then
         result := Format('%8.3' + dg, [valor])
      else if (DtmData.getConfiguracao As TConfiguracao).getQtdCasasDecimaisMostrarProduto = 4 Then
         result := Format('%8.4' + dg, [valor])
      else
         result := Format('%8.2' + dg, [valor]);  }
   end;
end;

//Funcao que resume a frase até a ocorrencia de números
function ResumirDescricao(chave: String): String;
var
   posi: integer;
begin
   posi := 0;

   if Pos('1', chave) > 0 then
      posi := Pos('1', chave)
   else if Pos('2', chave) > 0 then
      posi := Pos('2', chave)
   else if Pos('3', chave) > 0 then
      posi := Pos('3', chave)
   else if Pos('4', chave) > 0 then
      posi := Pos('4', chave)
   else if Pos('5', chave) > 0 then
      posi := Pos('5', chave)
   else if Pos('6', chave) > 0 then
      posi := Pos('6', chave)
   else if Pos('7', chave) > 0 then
      posi := Pos('7', chave)
   else if Pos('8', chave) > 0 then
      posi := Pos('8', chave)
   else if Pos('9', chave) > 0 then
      posi := Pos('9', chave)
   else if Pos('0', chave) > 0 then
      posi := Pos('0', chave);

   if (posi > 0) then
      Result := Trim(Copy(chave, 1, posi -1))
   else
      Result := chave;
end;

//TipoDFe para Integer
function TipoDFeToInt(tipo: TTipoDFe; tratarErro: boolean = false): integer;
var
   e: Exception;
begin
   if tipo = infNenhum then
      result := NULL_INTEGER
   else if tipo = infNFe then
      result := 0
   else if tipo = infCTe then
      result := 1
   else if tipo = InfNFSe then
      result := 2
   else if tipo = infMDFe then
      result := 3
   else if tipo = infNFCe then
      result := 4
   else if tipo = infOutros then
      result := 5
   else if tipo = infNenhum then
      result := 6;

   if ((tratarErro) and (result = NULL_INTEGER)) then
      Application.ShowException(E.Create('Erro do sistema! Tipo DF-e inválido!'));

end;

//Integer para TipoDFe
function IntToTipoDFe(tipo: integer; tratarErro: boolean = false): TTipoDFe;
var
   e: Exception;
begin
   if tratarErro then
      result := infNenhum;
      
   case tipo of
     -1: result := infNenhum;
      0: result := infNFe;
      1: result := infCTe;
      2: result := InfNFSe;
      3: result := infMDFe;
      4: result := infNFCe;
      5: result := infOutros;
      6: result := infNenhum;
   end;

   if ((tratarErro) and (result = infNenhum)) then
      Application.ShowException(E.Create('Erro do sistema! Tipo DF-e inválido!'));
end;

//TipoDFe para String
function TipoDFeToStr(tipo: TTipoDFe): String;
begin
   result := 'Nenhum';
   if tipo = infNFe then
      result := 'NF-E'
   else if tipo = infCTe then
      result := 'CT-E'
   else if tipo = InfNFSe then
      result := 'NFS-E'
   else if tipo = infMDFe then
      result := 'MDF-E'
   else if tipo = infNFCe then
      result := 'NFC-E'
   else if tipo = infOutros then
      result := 'OUTROS'
end;

//Iniciar conexao remota da tarefa agenda
function iniciarConexaoRemotaTA: Boolean;
begin
   result := False;

   {dtmData.getConexao.setUsuarioSec('TarefaAgendada');
   dtmData.getConexao.setSenhaSec('busterintech');
   dtmData.getConexao.setProtocolo(0);
   dtmData.getConexao.setServidorSec('caicolaticinios.ddns.net');
   dtmData.getConexao.setTipoAcesso(1);
   dtmData.getConexao.setBancoSec('INTECH_SUPORTE');

   result := dtmData.abrirConexaoRemota;}
end;

//Copiar arquivo de uma pasta para outra
procedure CopiarArquivoTXT(origem, destino: String);
var
   Arquivo: TStringList;
begin
   if (origem <> NULL_STRING) and (destino <> NULL_STRING) then
   begin
      Arquivo := TStringList.Create;
      try
         Arquivo.LoadFromFile(origem); // Carrega o arquivo de origem
         Arquivo.SaveToFile(destino); //salva o arquivo em outro lugar, como o mesmo nome, mas não necessária precisar ser com o mesmo nome.
      finally
         Arquivo.Free
      end;
   end;
end;

//BloquearInterface
procedure bloquearTodaInterface(MainMenu: TMainMenu);
var
   i, k, l: integer;
   mI  : TMenuItem;
begin
   //Bloquear toda interface
   for i := 0 to MainMenu.Items.Count - 1 do
   begin
      mI := MainMenu.Items[i];
      for k := 0 to mI.Count - 1 do
      begin
         mI.Items[k].Enabled := false;

         if (mI.Items[k].Count > 0) then
         begin
            for l := 0 to mI.Items[k].Count -1 do
               mI.Items[k].Items[l].Enabled := false;
         end;
      end;
   end;
end;

//SetFocusPorId
procedure setFocusPorId(form: TForm; id: integer);
var
   i: integer;
begin
   try
      with form do
      begin
         for i := 0 to (ComponentCount - 1) do
         begin
            if Components[i] is TEdit then
            begin
               if TEdit(Components[i]).TabOrder = id then
               begin
                  TEdit(Components[i]).SetFocus;
                  Abort;
               end;
            end else if Components[i] is TMaskEdit then
            begin
               if TMaskEdit(Components[i]).TabOrder = id then
               begin
                  TMaskEdit(Components[i]).SetFocus;
                  Abort;
               end;
            end else if Components[i] is TMemo then
            begin
               if TMemo(Components[i]).TabOrder = id then
               begin
                  TMemo(Components[i]).SetFocus;
                  Abort;
               end;
            end else if Components[i] is TCurrencyEdit then
            begin
               if TCurrencyEdit(Components[i]).TabOrder = id then
               begin
                  TCurrencyEdit(Components[i]).SetFocus;
                  Abort;
               end;
            end else if Components[i] is TTabSheet then
            begin
               if TTabSheet(Components[i]).TabOrder = id then
               begin
                  TTabSheet(Components[i]).SetFocus;
                  Abort;
               end;
            end else if Components[i] is TPageControl then
            begin
               if TPageControl(Components[i]).TabOrder = id then
               begin
                  TPageControl(Components[i]).ActivePageIndex := 0;
                  TPageControl(Components[i]).SetFocus;
                  Abort;
               end;
            end else if (Components[i] is TComboBox) and (TComboBox(Components[i]).Enabled) then
            begin
               if TComboBox(Components[i]).TabOrder = id then
               begin
                  TComboBox(Components[i]).SetFocus;
                  Abort;
               end;
            end;
         end;
      end;
   except
      //Caso o form ainda não tenha sido desenhado
   end;
end;

//Calcular desconto generico
function CalcularDesconto(valorTabela, valorFinal: currency; emPercentual: boolean): Currency;
begin
   //zerando o desconto ao usar o atacado varejo.
   //if not (dtmData.getConfiguracao As TConfiguracao).getHabilitarValorAtacadoVarejo Then
   begin
      valorTabela := Arredondar(valorTabela, 2);
      valorTabela := TruncTo(valorTabela, 2);

      valorFinal := Arredondar(valorFinal, 2);
      valorFinal := TruncTo(valorFinal, 2);

      if (valorTabela > 0) and (valorFinal > 0) then
      begin
         if emPercentual then
         begin
            if ValorTabela > ValorFinal Then
               result := ((valorTabela - valorFinal) * 100/ valorTabela)
            else
               result := 0;
               //result := ((valorFinal - valorTabela) * 100/ valorTabela)
         end
         else
         begin
            if ValorTabela > ValorFinal Then
               result := valorTabela - valorFinal
            else
               result := 0;
               //result := valorFinal - valorTabela;
         end;
      end
      else
         result := 0;
   end;
   //else
   //   result := 0;

   result := Arredondar(result, 2);
   result := TruncTo(result, 2);
end;

//Calcular comssao generico
function CalcularComissao(valorTotal, valorComissao: currency): Currency;
begin
   if (valorTotal > 0) and (valorComissao > 0) then
   begin
      result := ((valorComissao * 100) /valorTotal);
   end else
      result := 0;
end;

//Procurar cidade no combo
function procurarCidadeNome(combo: TOrComboBox; nome: string): integer;
var
   i, pos: integer;
begin
   pos := NULL_INTEGER;
   for i := 0 to combo.Items.Count -1 do
   begin
      if (pos = NULL_INTEGER) then
      begin
         if UpperCase(RemoverCaracterEspecial(combo.Items[i])) = UpperCase(RemoverCaracterEspecial(nome)) then
         begin
            pos := i;
            break;
         end;
      end;
   end;
   result := pos;
end;


//Procurar parte de uma string
function procurarSubString(texto: WideString; substring: String): integer;
begin
   result := pos(substring, String(texto));
end;

//Verificar campo so numeros
function isNumeric(chave: String): boolean;
begin
   result := length(strNumeros(chave)) = length(chave);
end;

//Trocar tab por Enter
procedure tabEnter(form: TForm; Sender: TObject; var Key: Char);
begin
   with form do
   begin
      if key = KEY_ENTER then
      begin
         key := KEY_TAB;
         Perform(WM_NEXTDLGCTL, 0, 0);
      end;
   end;
end;

//Configuracao padrao de um form
procedure organizarForm(form: TForm; xCaption: String);
begin
   with form do
   begin
      Caption := xCaption;
      BorderStyle := bsDialog;
      Position := poScreenCenter;
      KeyPreview := true;
      ShowHint := true;
   end;
   limparInterface(form);
end;

function VerTipoDadoStrExcel(valor: String): integer;
var
   val: String;
begin
   result := NULL_INTEGER;
   valor := Trim(valor);

   if valor <> NULL_STRING Then
   begin
      if (result = NULL_INTEGER) then
      begin
         val := copy(valor, 1, 2);
         if (val = 'R$') then
            result := 0;
      end;

      if (result = NULL_INTEGER) then
      begin
         if (Length(valor) = Length(strNumeros(valor))) then
            result := 1;

         if (result = NULL_INTEGER) then
         begin
            val := copy(valor, Length(valor) - 2, 3);
            if (val = '000') then
               result := 1;
         end;
      end;

      if (result = NULL_INTEGER) then
      begin
         val := copy(valor, Length(valor) - 2, 1);
         if ((val = ',') or (val = '.')) then
            result := 2;
      end;

      if (result = NULL_INTEGER) then
      begin
         val := copy(valor, 3, 1);
         if ((val = '/') or (val = '-')) then
            result := 3;
      end;

   end;
end;

function TratarStrExcel(valor: String): String;
begin
   valor := Trim(valor);
   result := valor;
   try
      case VerTipoDadoStrExcel(valor) of
         0: result := copy(valor, 3, Length(valor));
         1: result := FloatToIntStr(StrToValor(valor), 0);
         2: result := FloatToStr(StrToValor(valor));
         3: result := ' ' + Copy(valor, 1, 2) + '/' + Copy(valor, 4, 2) + '/' + Copy(valor, 7, 4);
         //3: result := FormatDateTime('dd/mm/yyyy', (StrToData2(Valor)));
      end;
   except
   end;
end;
{
   valorProc := Trim(valor);
   try
      val := copy(valorProc, 1, 2);
      if (val = 'R$') then
      begin
         valorProc := copy(valorProc, 3, Length(valorProc));
         result := Trim(valorProc);
      end else
      begin
         val := copy(valorProc, Length(valorProc) - 3, 3);
         if (val = '000') then
            result := FloatToIntStr(StrToValor(valorProc), 0);

         if (result = NULL_STRING) then
         begin
            val := copy(valorProc, Length(valorProc) - 3, 1);
            if (val = ',') or (val = '.') then
               result := FloatToStr(StrToValor(valorProc))
            else
               result := valor;
         end;
      end;
   except
      result := valor;
   end;
end;   }


//ExportarGridparaExcel
function exportarGridExcel(grid: TOrStringGrid; caminhoNomeArq: String; excessaoSilenciosa: boolean = false; visualizarExcel: boolean = true): boolean;
var
   i, j: integer;
   excel: variant;
   ehCodBarra: boolean;
begin
   result := false;

   try
      excel := CreateOleObject('Excel.Application');
      excel.Workbooks.add(1);

      for i := 0 to grid.RowCount -1 do
      begin
         for j := 0 to grid.ColCount -1 do
         begin
            case VerTipoDadoStrExcel(grid.Cells[j, i]) of
               0: Excel.WorkBooks[1].Sheets[1].cells[i + 1, j + 1].NumberFormat := 'R$ #.##0,00_);(R$ #.##0,00)';
               1: Excel.WorkBooks[1].Sheets[1].cells[i + 1, j + 1].NumberFormat := '#.#;(#.#)'; //'#,##0.0_);[Red](#,##0.0)'; na cor vermelho
               2: Excel.WorkBooks[1].Sheets[1].cells[i + 1, j + 1].NumberFormat := '#.##0,00_);(#.##0,00)';
               3: Excel.WorkBooks[1].Sheets[1].cells[i + 1, j + 1].NumberFormat := '';
            end;
            ehCodBarra := (Length(strNumeros(grid.Cells[j, i])) = 13) and (Length(grid.Cells[j, i]) = 13);
            if ehCodBarra then
               Excel.WorkBooks[1].Sheets[1].cells[i + 1, j + 1].NumberFormat := '#0_);(#0)';

            excel.cells[i + 1, j + 1] := TratarStrExcel(grid.Cells[j, i]);
         end;
      end;

      Excel.Visible := visualizarExcel;
      Excel.columns.AutoFit; // esta linha é para fazer com que o Excel dimencione as células adequadamente.
      try
         if (caminhoNomeArq <> NULL_STRING) then
            Excel.WorkBooks[1].SaveAs(caminhoNomeArq);
         result := true;
      except
         on e : Exception do
         begin
            if not excessaoSilenciosa then
               MessageDlg('Erro ao exportar para Excel ' +#13+
                          '================'+#13+#13+
                          'Menssagem : ' + E.Message +#13+
                          'Classe : '    + E.ClassName, mtError, [mbOK], 0);
            result := false;
         end;
      end;
      if not visualizarExcel then
      begin
         excel.ActiveWindow.Close(SaveChanges := 0);
         excel.Quit;
      end;
   except
      if not excessaoSilenciosa then
         Application.MessageBox ('Versão do Ms-Excel Incompatível', 'Erro', MB_OK + MB_ICONEXCLAMATION);
   end;
end;

//MemorizarAcaoDeBotao
procedure memorizarBotao(leitura: boolean; out idBotao: integer);
var
   aux: String;
   arq: TIniFile;
begin
   if ((idBotao < 1) or (idBotao > 4)) then
      idBotao := 1;

   aux := ExtractFilePath(Application.ExeName) + 'intechMemo.ini';
   if not FileExists(aux) then
   begin
      arq := TIniFile.Create(aux);
      arq.WriteInteger('MessageBox', 'idBotao', idBotao);
   end else
   begin
      Arq := TIniFile.Create(aux);

      if leitura then
         idBotao := Arq.ReadInteger('MessageBox', 'idBotao', 1)
      else
      begin
         Arq.WriteInteger('MessageBox', 'idBotao', idBotao);
         Arq.UpdateFile;
      end;
   end;
end;

//TipoLancamentoToChar
function TipoLancamentoToChar(tipo: TTipoLancamento): String;
begin
   if (tipo = tlFinanceiro) then
      result := 'F'
   else if (tipo = tlManual) then
      result := 'M'
   else if (tipo = tlPedido) then
      result := 'P'
   else if (tipo = tlTicket) then
      result := 'T'
   else
      result := 'F';
end;

function CharToTipoLancamento(tipo: String): TTipoLancamento;
begin
   tipo := UpperCase(tipo);

   if (tipo = 'F') then
      result := tlFinanceiro
   else if (tipo = 'M') then
      result := tlManual
   else if (tipo = 'P') then
      result := tlPedido
   else if (tipo = 'T') then
      result := tlTicket
   else
      result := tlFinanceiro;
end;

//Calcular o tempo em horas ou Dias.
function FormatHoras(time: double; havDay: boolean): string;
var
   dias, horas: double;
   Pos1, horas24: integer;
   aux1: string;
begin
   dias  := trunc(time);
   horas := frac(time);

   if havDay then
      Result  := FloatToStr(dias) //+ 'd '// + TimeToStr(horas)
   else
   begin
      aux1    := TimeToStr(horas);
      pos1    := pos(':', aux1);
      horas24 := StrToInt(copy(aux1, 1, pos1 -1)) + (trunc(dias) * 24);
      Result  := IntToStr(horas24) + Copy(aux1, pos1, Length(aux1));
  end;
end;

//limpar Dados da Grid
procedure limparDadosGrid(grid: TStringGrid);
var
   i, j: integer;
begin
   if grid.FixedRows = 0 then
   begin
      for i := 0 to grid.RowCount -1 do
         for j := 0 to grid.ColCount -1 do
            grid.Cells[j, i] := '';
   end else
   begin
      for i := 1 to grid.RowCount do
         for j := 0 to grid.ColCount -1 do
            grid.Cells[j, i] := '';
   end;
end;

//CaracteristicaPetToINT
function tipoCaracteristicaAnimalToInt(tipoCaracteristicaAnimal: TTipoCaracteristicaAnimal): integer;
begin
   result := -1;
   if tipoCaracteristicaAnimal = tcaRaca then
      result := 0
   else if tipoCaracteristicaAnimal = tcaEspecie then
      result := 1
   else if tipoCaracteristicaAnimal = tcaPelagem then
      result := 2
   else if tipoCaracteristicaAnimal = tcaIndefinido then
      result := 3;
end;

//INTtoCaracteristicaPet
function IntToTipoCaracteristicaAnimal(tipo: integer): TTipoCaracteristicaAnimal;
begin
   result := tcaIndefinido;
   case tipo of
      0: result := tcaRaca;
      1: result := tcaEspecie;
      2: result := tcaPelagem;
      3: result := tcaIndefinido;
   end;
end;

//LimparGrid
procedure limparGrid(grid: TStringGrid);
var
   i, j: integer;
begin
   for i := 1 to grid.RowCount do
      for j := 1 to grid.ColCount do
         grid.Cells[j, i] := NULL_STRING;
end;

//Calcular margem de lucro
function calcularMargemLucro(valorCusto, valorVenda: currency): currency;
begin
   if (valorVenda <> 0) and (valorCusto <> 0) then
      result := ((valorVenda * 100)/valorCusto) - 100
   else
      result := 0;

   result := FormatarValor2(result, 2);
end;

//Gerar arquivo TXT
procedure gerarArquivoTexto(diretorio, nomeArq: WideString; conteudo: WideString);
var
  arq: TextFile;
begin
   if not DiretorioExiste(diretorio) then
      CreateDir(diretorio);

   try
      AssignFile(arq, diretorio + nomeArq);
      Rewrite(arq);
      Writeln(arq, conteudo);
   finally
      closeFile(arq);
   end;
end;

function InputComData(var Data: string): boolean;
var 
  Form: TForm;
  Edt: TOrDateEdit;
begin
  Result := false;

  Form := TForm.Create(Application);
  try
    {config form}
    Form.BorderStyle := bsDialog;
    Form.Caption := 'Data';
    Form.Position := poScreenCenter;
    Form.Width := 200;
    Form.Height := 150;

    {config label}
    with TLabel.Create(Form) do begin
      Parent := Form;
      Caption := 'Entre com a data:';
      Left := 10;
      Top := 10;
    end;

    {config edit mask}
    {Edt := TMaskEdit.Create(Form);
    with Edt do begin
      Parent := Form;
      Left := 10;
      Top := 25;
      Width := Form.ClientWidth - 20;
      EditMask := '!99/99/0000;1;_';
    end;}
    Edt := TOrDateEdit.Create(Form);
    with Edt do begin
      Parent := Form;
      Left := 10;
      Top := 25;
      Width := Form.ClientWidth - 20;
    end;

    {config btn ok}
    with TBitBtn.Create(Form) do begin
      Parent := Form;
      { Posiciona de acordo com a largura do form }
      Left := Form.ClientWidth - (Width * 2) - 20;
      Top := 70;
      Kind := bkOK;
    end;

    {config btn cancel} 
    with TBitBtn.Create(Form) do begin 
      Parent := Form; 
      Left := Form.ClientWidth - Width - 10; 
      Top := 70; 
      Kind := bkCancel; { Botão Cancel } 
    end; 

    {Se for OK... } 
    if Form.ShowModal = mrOK then begin 
      if edt.Text = '  /  /    ' then 
        Data := '' 
      else 
        Data := Edt.Text; 
      Result := true; 
    end; 
  finally
    Form.Free; 
  end; 
end;

//Converter uma string para StringList
function StringToStringList(S : String; separador : char): TStringList;
  var
  conta : integer; // variáveis auxiliares
  resultado : TStringList; // variáveis auxiliares
  Saux : string; // variáveis auxiliares
begin
    resultado := TStringList.Create; // inicializa variavel
    conta := pos(separador,S); //pega posição do separador
    if conta <> 0 then begin  // verifica se existe o separador caso contrario trata apenas //como uma única linha
        while trim(S) <> '' do begin // enquanto S não for nulo executa
            Saux := copy(S,1,conta-1); // Variável Saux recebe primeiro valor
            delete(S,1,conta); //deleta primeiro valor
            if conta = 0 then begin //se não ouver mais separador Saux equivale ao resto da //linha
                Saux := S;
                S := '';
            end;
        resultado.Add(Saux); // adiciona linhas na string lista
        conta := pos(separador,S); //pega posição do separador
        end;
    end else begin
        Saux := S;
        resultado.Add(Saux);
    end;
    Result := resultado; // retorna resultado como uma lista indexada
end;

//Converter uma string para uma StringList de Instruções SQL
function StringToSqlList(S : String): TStringList;
var
   resultado: TStringList;
   sInst, eInst : integer;
   Saux, ini, fim : string;
begin
   resultado := TStringList.Create; // inicializa variavel

   ini := '--<Instruction>';
   fim := '--<Instruction/>';

   //pega posição dos separadores
   sInst := pos(ini, S);
   eInst := pos(fim, S);

   // verifica se existe o separador
   // caso contrario trata apenas como uma única linha
   if sInst <> 0 then
   begin
      // enquanto S não for vazio executa
      while trim(S) <> '' do
      begin
         // Variável Saux recebe primeira instrução contida em S
         Saux := '';
         Saux := copy(S, sInst + ini.Length, eInst - sInst - fim.Length + 1);

         //deleta a primeira instrução
         delete(S, 1, (eInst -1) + fim.Length);

         // adiciona linhas na string lista
         resultado.Add(Saux);

         // atualiza a posição do separador
         sInst := pos(ini, S);
         eInst := pos(fim, S);
      end;
   end
   else
   begin
      Saux := S;
      resultado.Add(Saux);
   end;

   // retorna resultado como uma lista indexada
   Result := resultado;
end;

//Verificar combo preenchido
function VerificarComboPreenchido(cmb: TOrComboBox): boolean;
begin
   result := (cmb.ItemIndex <> POS_NAO_ENCONTRADA) and (cmb.Text <> NULL_STRING);
end;

//Ordenar StringGrid por coluna
procedure OrdenarStringGrid(GenStrGrid: TStringGrid; ThatCol: Integer);
const 
  // Define the Separator
  TheSeparator = '@';
var
  CountItem, I, J, K, ThePosition: integer;
  MyList: TStringList;
  MyString, TempString: string;
begin
  // Give the number of rows in the StringGrid
  CountItem := GenStrGrid.RowCount;
  //Create the List
  MyList        := TStringList.Create;
  MyList.Sorted := False;
  try
    begin
      for I := 1 to (CountItem - 1) do
        MyList.Add(GenStrGrid.Rows[I].Strings[ThatCol] + TheSeparator +
          GenStrGrid.Rows[I].Text);
      //Sort the List
      Mylist.Sort;

      for K := 1 to Mylist.Count do
      begin
        //Take the String of the line (K  1)
        MyString := MyList.Strings[(K - 1)];
        //Find the position of the Separator in the String
        ThePosition := Pos(TheSeparator, MyString);
        TempString  := '';
        {Eliminate the Text of the column on which we have sorted the StringGrid}
        TempString := Copy(MyString, (ThePosition + 1), Length(MyString));
        MyList.Strings[(K - 1)] := '';
        MyList.Strings[(K - 1)] := TempString;
      end;
      // Refill the StringGrid
      for J := 1 to (CountItem - 1) do
        GenStrGrid.Rows[J].Text := MyList.Strings[(J - 1)];
    end;
  finally
    //Free the List
    MyList.Free;
  end;
end;

//Calcular percentual sobre o valor total
function CalcularPercentualTotal(valorTotal, valor: double): double;
begin
   if (valor <> 0) and (valorTotal <> 0) then
      result := (valor / valorTotal) * 100
   else
      result := 0;
end;

//Método para o sistema falar um texto.
procedure Falar(texto: String);
var
   Arquivo: TextFile;
begin
   if FileExists('C:\FALASISTEMA.VBS') then
      deleteFile('C:\FALASISTEMA.VBS');

   AssignFile(Arquivo,'C:\FALASISTEMA.VBS');
   Rewrite(Arquivo);
   Writeln(Arquivo, 'Dim message, sapi');
   Writeln(Arquivo, 'message="' + texto + '"');
   Writeln(Arquivo, 'Set sapi=CreateObject("sapi.spvoice")');
   Writeln(Arquivo, 'sapi.Speak message');
   CloseFile(Arquivo);
   ShellExecute(0, 'Open', PChar('C:\FALASISTEMA.VBS'), nil, nil, Ord(SW_HIDE));
end;

//Converter tipo PF ou PJ para String
function tipoPessoaToString(pessoaFisica: boolean): String;
begin
   if pessoaFisica then
      result := 'CPF'
   else
      result := 'CNPJ';
end;

// versões IE: 7, 8, 9 10 e 11
Procedure SetIEEmulation(VersaoIE : Integer);
Var
   R : TRegistry;
   V : Integer;
Begin
   V := 11001;
   Case VersaoIE Of
      7 : V := 7000;
      8 : V := 8888;
      9 : V := 9999;
      10 : V := 10001;
      11 : V := 11001;
   End;
   // internet explorer 11 = 11000 ou 11001
   // internet explorer 10 = 10000 ou 10001
   // internet explorer 9 = 9000 ou 9999
   // internet explorer 8 = 8000 ou 8888
   // internet explorer 7 = 7000
   // https://msdn.microsoft.com/en-us/library/ee330730%28v=vs.85%29.aspx
   // resumidamente, esta função grava um valor no registro que força a emulação da versão do Internet Explorer para o programa indicado
   // só é preciso o nome do programa, não é necessário o path completo
   R := TRegistry.Create;
   Try
      R.RootKey := HKEY_CURRENT_USER;
      R.OpenKey('SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION\',False);
      // código para emular o internet explorer 11
      R.WriteInteger(ExtractFileName(ParamStr(0)),V);
   Finally
      R.CloseKey;
      R.Free;
   End;
End;

//Validar codigo de barras GTIN
function ValidaCodigoGTIN(Codigo:String): Boolean;
begin
   Result := EAN13Valido(Codigo);
end;

function VerificarPrefixoEAN(Codigo:String): Boolean;
var
   prefixo: Integer;
begin
  try
   result := (Length(Codigo) = 13) and (InRange(StrToInt(Copy(codigo, 1, 3)), 020, 984));

   if result then
   begin
      result := false;
      prefixo := StrToInt(Copy(codigo, 1, 3));
      if InRange(prefixo,020,380) then
        result := true
      else if InRange(prefixo,383,383) then
        result := true
      else if InRange(prefixo,385,385) then
        result := true
      else if InRange(prefixo,387,387) then
        result := true
      else if InRange(prefixo,389,389) then
        result := true
      else if InRange(prefixo,400,440) then
        result := true
      else if InRange(prefixo,450,459) then
        result := true
      else if InRange(prefixo,490,499) then
        result := true
      else if InRange(prefixo,460,469) then
        result := true
      else if InRange(prefixo,470,471) then
        result := true
      else if InRange(prefixo,474,489) then
        result := true
      else if InRange(prefixo,500,509) then
        result := true
      else if InRange(prefixo,520,521) then
        result := true
      else if InRange(prefixo,528,531) then
        result := true
      else if InRange(prefixo,535,535) then
        result := true
      else if InRange(prefixo,539,549) then
        result := true
      else if InRange(prefixo,560,560) then
        result := true
      else if InRange(prefixo,569,579) then
        result := true
      else if InRange(prefixo,590,590) then
        result := true
      else if InRange(prefixo,594,594) then
        result := true
      else if InRange(prefixo,599,601) then
        result := true
      else if InRange(prefixo,603,604) then
        result := true
      else if InRange(prefixo,608,609) then
        result := true
      else if InRange(prefixo,611,611) then
        result := true
      else if InRange(prefixo,613,613) then
        result := true
      else if InRange(prefixo,615,616) then
        result := true
      else if InRange(prefixo,618,629) then
        result := true
      else if InRange(prefixo,640,649) then
        result := true
      else if InRange(prefixo,690,709) then
        result := true
      else if InRange(prefixo,729,746) then
        result := true
      else if InRange(prefixo,750,750) then
        result := true
      else if InRange(prefixo,754,755) then
        result := true
      else if InRange(prefixo,759,771) then
        result := true
      else if InRange(prefixo,773,773) then
        result := true
      else if InRange(prefixo,775,775) then
        result := true
      else if InRange(prefixo,777,780) then
        result := true
      else if InRange(prefixo,784,784) then
        result := true
      else if InRange(prefixo,786,786) then
        result := true
      else if InRange(prefixo,789,790) then
        result := true
      else if InRange(prefixo,800,850) then
        result := true
      else if InRange(prefixo,858,860) then
        result := true
      else if InRange(prefixo,865,865) then
        result := true
      else if InRange(prefixo,867,880) then
        result := true
      else if InRange(prefixo,884,885) then
        result := true
      else if InRange(prefixo,888,890) then
        result := true
      else if InRange(prefixo,893,893) then
        result := true
      else if InRange(prefixo,896,896) then
        result := true
      else if InRange(prefixo,899,919) then
        result := true
      else if InRange(prefixo,930,939) then
        result := true
      else if InRange(prefixo,940,951) then
        result := true
      else if InRange(prefixo,955,955) then
        result := true
      else if InRange(prefixo,958,958) then
        result := true
      else if InRange(prefixo,960,969) then
        result := true
      else if InRange(prefixo,977,984) then
        result := true;
   end;
  except
    result := false;
  end;
end;

function executarComando(comando: string): boolean;
var
   StartupInfo       : TStartupInfo;
   ProcessInformation: TProcessInformation;
   rc                : Boolean;
begin
   FillChar(StartupInfo, SizeOf(StartupInfo), #0);
   with StartupInfo do
      cb := SizeOf(StartupInfo);
   rc := CreateProcess(nil, PChar(comando), nil, nil, false, NORMAL_PRIORITY_CLASS, nil, nil, StartupInfo, ProcessInformation);
   if rc then
   begin
      WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
      result := true;
   end
   else
   begin
      raise Exception.Create(comando + #13 + ' não encontrado neste computador.');
      result := false;
   end;
end;

//Lancar lembrete na barra de tarefa
procedure LancarLembreBarraTarefa;
var
   ArqBat: String;
   f: TextFile;
   descricao: String;
begin
   if not DirectoryExists('C:\Lembretes') then
   begin
      ForceDirectories('C:\Lembretes');
      if not DirectoryExists('C:\Lembretes\Lembrete') then
         ForceDirectories('C:\Lembretes\Lembrete');
   end;

   if not FileExists('C:\Lembretes\Template.lnk') then
      FileCreate('C:\Lembretes\Template.lnk');
   {if not FileExists('C:\Lembretes\Script.bat') then
      FileCreate('C:\Lembretes\Script.bat');}

   ArqBat := 'C:\Lembretes\Script.bat';

   AssignFile(f, ArqBat);
   try
      {Rewrite(f);
      Writeln(f, '@echo off');
      Writeln(f, 'SET /P X=Insira o lembrete:');
      Writeln(f, 'COPY "C:\Lembretes\Template.lnk" "C:\Lembretes\Lembrete\%X%.lnk"');
      Writeln(f, 'SET X=');
      CloseFile(f);}
      if InputQuery('Lançar lembrete', 'Insira o lembrete:', descricao) then
      begin
         if descricao <> NULL_STRING then
         begin
            Rewrite(f);
            Writeln(f, '@echo off');
            Writeln(f, 'SET X=' + descricao);
            Writeln(f, 'COPY "C:\Lembretes\Template.lnk" "C:\Lembretes\Lembrete\%X%.lnk"');
            Writeln(f, 'SET X=');
            CloseFile(f);
         end;
      end;
   except
      raise;
   end;
   executarComando('C:\Lembretes\Script.bat');
end;

//Gravar e ler a posicao dos componentes com base na ultima utilizacao
//MemorizarAcaoDeBotao
procedure memorizarForm(leitura: boolean; form: TForm);
var
   aux: String;
   arq: TIniFile;
   i: integer;
begin
   aux := ExtractFilePath(Application.ExeName) + form.Name + '.ini';
   if leitura then
   begin
      if FileExists(aux) then
      begin
         //if Application.MessageBox('Deseja recuperar último Status?', 'Recuperar Status', MB_OKCANCEL + MB_ICONQUESTION) = IDOK then
         begin
            arq := TIniFile.Create(aux);
            with form do
            begin
               for i := 0 to (ComponentCount - 1) do
               begin
                  if Components[i] is TRadioGroup then
                     TRadioGroup(Components[i]).ItemIndex := Arq.ReadInteger('Componente', TRadioGroup(Components[i]).Name, 0)
                  else if Components[i] is TCheckBox then
                     TCheckBox(Components[i]).Checked := IntegerToBoolean(Arq.ReadInteger('Componente', TCheckBox(Components[i]).Name, 0))
                  else if (Components[i] is TComboBox) and (TComboBox(Components[i]).Enabled) and (TComboBox(Components[i]).Items.Count > 1) then
                     TComboBox(Components[i]).ItemIndex := Arq.ReadInteger('Componente', TComboBox(Components[i]).Name, POS_NAO_ENCONTRADA)
                  else if Components[i] is TRadioButton then
                     TRadioButton(Components[i]).Checked := IntegerToBoolean(Arq.ReadInteger('Componente', TRadioButton(Components[i]).Name, 0))
                  else if Components[i] is TEdit then
                     TEdit(Components[i]).Text := Arq.ReadString('Componente', TEdit(Components[i]).Name, NULL_STRING)
                  else if Components[i] is TDirectoryEdit then
                     TDirectoryEdit(Components[i]).Text := Arq.ReadString('Componente', TDirectoryEdit(Components[i]).Name, NULL_STRING);
               end;
            end;
         end;
      end;
   end else
   begin
      arq := TIniFile.Create(aux);
      with form do
      begin
         for i := 0 to (ComponentCount - 1) do
         begin
            if Components[i] is TRadioGroup then
               Arq.WriteInteger('Componente', TRadioGroup(Components[i]).Name, TRadioGroup(Components[i]).ItemIndex)
            else if Components[i] is TCheckBox then
               Arq.WriteInteger('Componente', TCheckBox(Components[i]).Name, booleanToInteger(TCheckBox(Components[i]).Checked))
            else if (Components[i] is TComboBox) and (TComboBox(Components[i]).Enabled) and (TComboBox(Components[i]).Items.Count > 1) then
               Arq.WriteInteger('Componente', TComboBox(Components[i]).Name, TComboBox(Components[i]).ItemIndex)
            else if Components[i] is TRadioButton then
               Arq.WriteInteger('Componente', TRadioButton(Components[i]).Name, booleanToInteger(TRadioButton(Components[i]).Checked))
            else if Components[i] is TEdit then
               Arq.WriteString('Componente', TEdit(Components[i]).Name, TEdit(Components[i]).Text)
            else if Components[i] is TDirectoryEdit then
               Arq.WriteString('Componente', TDirectoryEdit(Components[i]).Name, TEdit(Components[i]).Text);
         end;
         Arq.UpdateFile;
      end;
   end;
end;

procedure memorizarFrame(leitura: boolean; frame: TFrame);
var
   aux: String;
   arq: TIniFile;
   i: integer;
begin
   aux := ExtractFilePath(Application.ExeName) + frame.Name + '.ini';
   if leitura then
   begin
      if FileExists(aux) then
      begin
         //if Application.MessageBox('Deseja recuperar último Status?', 'Recuperar Status', MB_OKCANCEL + MB_ICONQUESTION) = IDOK then
         begin
            arq := TIniFile.Create(aux);
            with frame do
            begin
               for i := 0 to (ComponentCount - 1) do
               begin
                  if Components[i] is TRadioGroup then
                     TRadioGroup(Components[i]).ItemIndex := Arq.ReadInteger('Componente', TRadioGroup(Components[i]).Name, 0)
                  else if Components[i] is TCheckBox then
                     TCheckBox(Components[i]).Checked := IntegerToBoolean(Arq.ReadInteger('Componente', TCheckBox(Components[i]).Name, 0))
                  else if (Components[i] is TComboBox) and (TComboBox(Components[i]).Enabled) and (TComboBox(Components[i]).Items.Count > 1) then
                     TComboBox(Components[i]).ItemIndex := Arq.ReadInteger('Componente', TComboBox(Components[i]).Name, POS_NAO_ENCONTRADA)
                  else if Components[i] is TRadioButton then
                     TRadioButton(Components[i]).Checked := IntegerToBoolean(Arq.ReadInteger('Componente', TRadioButton(Components[i]).Name, 0))
                  else if Components[i] is TEdit then
                     TEdit(Components[i]).Text := Arq.ReadString('Componente', TEdit(Components[i]).Name, NULL_STRING);
               end;
            end;
         end;
      end;
   end else
   begin
      arq := TIniFile.Create(aux);
      with frame do
      begin
         for i := 0 to (ComponentCount - 1) do
         begin
            if Components[i] is TRadioGroup then
               Arq.WriteInteger('Componente', TRadioGroup(Components[i]).Name, TRadioGroup(Components[i]).ItemIndex)
            else if Components[i] is TCheckBox then
               Arq.WriteInteger('Componente', TCheckBox(Components[i]).Name, booleanToInteger(TCheckBox(Components[i]).Checked))
            else if (Components[i] is TComboBox) and (TComboBox(Components[i]).Enabled) and (TComboBox(Components[i]).Items.Count > 1) then
               Arq.WriteInteger('Componente', TComboBox(Components[i]).Name, TComboBox(Components[i]).ItemIndex)
            else if Components[i] is TRadioButton then
               Arq.WriteInteger('Componente', TRadioButton(Components[i]).Name, booleanToInteger(TRadioButton(Components[i]).Checked))
            else if Components[i] is TEdit then
               Arq.WriteString('Componente', TEdit(Components[i]).Name, TEdit(Components[i]).Text);
         end;
         Arq.UpdateFile;
      end;
   end;
end;

procedure memorizarPopUpMenu(leitura: boolean; form: TForm; popUpMenu: TPopupMenu);
var
   aux, nome: String;
   arq: TIniFile;
   i: integer;
begin
   aux := ExtractFilePath(Application.ExeName) + form.Name + '.ini';
   if leitura then
   begin
      if FileExists(aux) then
      begin
         begin
            arq := TIniFile.Create(aux);
            for i := 0 to (popUpMenu.Items.Count - 1) do
            begin
               try
                  nome := popUpMenu.Items[i].Name;
                  if (nome <> NULL_STRING) then
                     popUpMenu.Items[i].Checked := Arq.ReadBool('PopUp', nome, false);
               except
               end;
            end;
         end;
      end;
   end else
   begin
      arq := TIniFile.Create(aux);
      for i := 0 to (popUpMenu.Items.Count - 1) do
      begin
         try
            nome := popUpMenu.Items[i].Name;
            if (nome <> NULL_STRING) then
               Arq.WriteBool('PopUp', nome, popUpMenu.Items[i].Checked);
         except
         end;
      end;
      Arq.UpdateFile;
   end;
end;

procedure memorizarCheckBox(leitura: boolean; form: TForm; apenas: String = NULL_STRING);
var
   aux: String;
   arq: TIniFile;
   i: integer;
begin
   aux := ExtractFilePath(Application.ExeName) + form.Name + '.ini';
   if leitura then
   begin
      if FileExists(aux) then
      begin
         //if Application.MessageBox('Deseja recuperar último Status?', 'Recuperar Status', MB_OKCANCEL + MB_ICONQUESTION) = IDOK then
         begin
            arq := TIniFile.Create(aux);
            with form do
            begin
               for i := 0 to (ComponentCount - 1) do
               begin
                  if Components[i] is TCheckBox then
                  begin
                     if (apenas <> NULL_STRING) then
                     begin
                        if (TCheckBox(Components[i]).Name = apenas) then
                           TCheckBox(Components[i]).Checked := Arq.ReadBool('Componente', TCheckBox(Components[i]).Name, false)
                     end else
                        TCheckBox(Components[i]).Checked := Arq.ReadBool('Componente', TCheckBox(Components[i]).Name, false);
                  end;
               end;
            end;
         end;
      end;
   end else
   begin
      arq := TIniFile.Create(aux);
      with form do
      begin
         for i := 0 to (ComponentCount - 1) do
         begin
            if Components[i] is TCheckBox then
            begin
               if (apenas <> NULL_STRING) then
               begin
                  if (TCheckBox(Components[i]).Name = apenas) then
                     Arq.WriteBool('Componente', TCheckBox(Components[i]).Name, TCheckBox(Components[i]).Checked);
               end else
                  Arq.WriteBool('Componente', TCheckBox(Components[i]).Name, TCheckBox(Components[i]).Checked);
            end;
         end;
         Arq.UpdateFile;
      end;
   end;
end;

//Status ticket
function StatusTicketToChar(status: TStatusTicket): String;
begin
   if (status = stAberto) then
      result := 'A'
   else if (status = stVisto) then
      result := 'V'
   else if (status = stFinalizado) then
      result := 'F'
   else if (status = stCancelado) then
      result := 'C'
   else if (status = stIndefinido) then
      result := 'I'
   else
      result := 'A';
end;

function CharToStatusTicket(status: String): TStatusTicket;
begin
   status := UpperCase(status);
   if (status = 'A') then
      result := stAberto
   else if (status = 'V') then
      result := stVisto
   else if (status = 'F') then
      result := stFinalizado
   else if (status = 'C') then
      result := stCancelado
   else if (status = 'I') then
      result := stIndefinido
   else
      result := stAberto;
end;

function IntToStatusTicket(status: integer): TStatusTicket;
begin
   result := stIndefinido;
   case status of
      0: result := stAberto;
      1: result := stVisto;
      2: result := stFinalizado;
      3: result := stCancelado;
      4: result := stIndefinido;
   end;
end;

function TipoMovimentoToint(tipo: TTipoMovimentoCaixa): integer;
begin
   if tipo = tmEntrada then
      result := 0
   else
      result := 1;
end;

function TipoMovimentoToChar(tipo: TTipoMovimentoCaixa): String;
begin
   if tipo = tmEntrada then
      result := 'E'
   else
      result := 'S';
end;

function IntToTipoMovimento(tipo: integer): TTipoMovimentoCaixa;
begin
   if not (tipo in [0,1]) then
      raise ETipoMovimentoInvalido.Create('Tipo de movimento inválido. O movimento de caixa deve ser de Entrada ou Saída.')
   else
   begin
      case tipo of
         0: result := tmEntrada;
         1: result := tmSaida;
      end;
   end;
end;

function CharToTipoMovimento(tipo: String): TTipoMovimentoCaixa;
begin
   if not ((tipo[1] = 'E') or (tipo[1] = 'S')) then
      raise ETipoMovimentoInvalido.Create('Tipo de movimento inválido. O movimento de caixa deve ser de Entrada ou Saída.')
   else
   begin
      if (tipo[1] = 'E') then
         result := tmEntrada
      else
         result := tmSaida;
   end;
end;

//Order String Grid por coluna
procedure OrdenarGrid(grid: TStringGrid; coluna, tipoDados: integer; decrescente, total: boolean);
begin
   //tipoDados: 1: Conteúdo numérico; 2: String; 3: Data
   IntechStringGrid.StrGridSort(grid, coluna, tipoDados, decrescente, total);
end;

procedure OrdenarGridMouseDown(grid: TStringGrid; Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
Var
   Valor :String;
   tipo : integer;
   LGcCoord: TGridCoord; //Define as coordenadas do mouse na grid
begin
   LGcCoord := TCustomGrid(grid).MouseCoord(x,y);
   GiCol := LGcCoord.X;
   GiRow := LGcCoord.Y;
   if (GiRow = 0) And (Button = mbleft) And (GiCol <> -1) then
   Begin
      with grid do
      Begin
         GCelda := CellRect(GiCol,0);
         Valor := Cells[GiCol, 0];
         Canvas.Font := Font;
         Canvas.Brush.Color := clInactiveCaptionText;
         Canvas.FillRect(GCelda);
         Canvas.TextRect(GCelda, GCelda.Left + 2, GCelda.Top + 2, Valor);
         DrawEdge(Canvas.Handle, GCelda, 10, 2 or 4 or 8);
         DrawEdge(Canvas.Handle, GCelda, 2 or 4, 1);
      End;

      {if (grid.Cells[GiCol,1]='N') then
         tipo := 1
      else
      if (Grid.Cells[GiCol,1]='S') then
         tipo := 2
      else
         tipo := 3;}
         //tipoDados: 1: Conteúdo numérico; 2: String; 3: Data
      tipo := 2;

      if ( (GiCol >= 0) and (GiRow <= (Grid.RowCount-1)) ) then
      begin
         if (GiCol=coluna) then
         begin
            IntechStringGrid.StrGridSort(grid,GiCol,tipo, true, false);
            coluna := -1;
         end else
         begin
            IntechStringGrid.StrGridSort(grid,GiCol,tipo, false,false);
            coluna := GiCol;
         end;
      end;
   end;
end;

procedure OrdenarGridMouseUp(grid: TStringGrid; Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
Var
   Valor: String;
begin
   if (GiRow = 0) And (Button = mbleft) And (GiCol <> -1) then
   Begin
      with grid do
      Begin
         Valor := Cells[Gicol, 0];
         Canvas.Font := Font;
         Canvas.Brush.Color := clInactiveCaptionText;
         Canvas.FillRect(GCelda);
         Canvas.TextRect(GCelda, GCelda.Left + 2, GCelda.Top + 2, Valor);
         DrawEdge(Canvas.Handle, GCelda, 4, 4 or 8);
         DrawEdge(Canvas.Handle, GCelda, 4, 1 or 2);
         GCelda := grid.CellRect(1, 1);
      End;
   End;
end;

//Apagar linha ou coluna de um StringGrid
procedure ApagarLinhaStringGrid(RowNumber: Integer; Grid: TstringGrid);
var
  i: Integer;
begin
  try
     Grid.Row := RowNumber;
     if (Grid.Row = Grid.RowCount - 1) then
       { On the last row}
       Grid.RowCount := Grid.RowCount - 1
     else
     begin
       { Not the last row}
       for i := RowNumber to Grid.RowCount - 1 do
         Grid.Rows[i] := Grid.Rows[i + 1];
       Grid.RowCount := Grid.RowCount - 1;
     end;
  except
   //
  end;
end;

procedure MarcarLinhaStringGrid(RowNumber, ColNumber: Integer; Grid: TStringGrid; marcar: boolean);
begin
   if marcar then
      Grid.Cells[ColNumber, RowNumber] := '1'
   else
      Grid.Cells[ColNumber, RowNumber] := NULL_STRING;
end;

function posItemNaGrid(grid: TStringGrid; chave: String; coluna: integer): integer;
var
   i: integer;
begin
   result := -1;
   for i := 1 to grid.RowCount do
   begin
      if (Trim(grid.Cells[coluna, i]) = Trim(chave)) then
      begin
         result := i;
         Break;
      end;
   end;
end;

function PalavraConstaString(palavra, texto: String): boolean;
begin
   result := Pos(palavra, texto) <> 0;
end;

//Gerar ID ou Chave Única
function GerarChaveId: String;
var
  I, tipo: Integer;
  Chave: String;
const
  str1 = '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  str2 = '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  str3 = '1234567890abcdefghijklmnopqrstuvwxyz';
  str4 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  str5 = '1234567890';
  str6 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  str7 = 'abcdefghijklmnopqrstuvwxyz';
begin
  Chave := '';
  Tipo := 1;
  for I := 1 to 6 do
  begin
    case Tipo of
      1 : Chave := Chave + str1[Random(Length(str1)) + 1];
      2 : Chave := Chave + str2[Random(Length(str2)) + 1];
      3 : Chave := Chave + str3[Random(Length(str3)) + 1];
      4 : Chave := Chave + str4[Random(Length(str4)) + 1];
      5 : Chave := Chave + str5[Random(Length(str5)) + 1];
      6 : Chave := Chave + str6[Random(Length(str6)) + 1];
      7 : Chave := Chave + str7[Random(Length(str7)) + 1];
    end;
  end;

  Result := UpperCase(Chave);
end;

//Posicao de um caracter na String
function PosCharString(caracter: String; texto: String): integer;
begin
   result := Pos(caracter, texto);
end;


//ACBR
function enviarNotaEmail(porta, host, usuario, senha,
                         cabecalho, corpo, emailRemetente, nomeRemetente, emailDestinatario,
                         nomeDestinatario, anexo, chaveAcesso, arquivoPDF, fantasiaDestinatario, cidadeUF: string): boolean;
var
   CC: TStringList;
   lstMensagem, lstAnexo: TStrings;
begin
   //So usar nos modulos de NF-e

    if ValidaEMail(Pchar(emailDestinatario)) then
    begin
       lstMensagem := TStringList.Create;
       dtmData.ACBrNFe.NotasFiscais.Clear;
       dtmData.ACBrNFe.NotasFiscais.LoadFromFile(anexo);

       lstAnexo := TStringList.Create;
       lstAnexo.Add(anexo);

       CC := TstringList.Create;

       if corpo = NULL_STRING then
         corpo := nomeDestinatario + '-' + cidadeUF;
         
       if (cabecalho = NULL_STRING) then
       begin
         if (Trim(fantasiaDestinatario) <> NULL_STRING) then
            cabecalho := 'Olá ' + fantasiaDestinatario + '. Segue arquivo de nota fiscal'
         else
            cabecalho := 'Segue arquivo de nota fiscal';
       end;

       lstMensagem.Add(corpo);
       //CC.Add('intech.atualizacao@gmail.com '); //especifique um email válido

       dtmData.ACBrNFe.NotasFiscais.Items[0].EnviarEmail(emailDestinatario,
                                                         cabecalho,
                                                         lstMensagem,
                                                         true,
                                                         CC,
                                                         lstAnexo,
                                                         nil);
       CC.Free;
    end;

end;

function ValidaEMail(const EMailIn: PChar): Boolean;
const
  CaraEsp: array[1..40] of string[1] =
  ( '!','#','$','%','¨','&','*',
  '(',')','+','=','§','¬','¢','¹','²',
  '³','£','´','`','ç','Ç',',',';',':',
  '<','>','~','^','?','/','','|','[',']','{','}',
  'º','ª','°');
var
  i,cont   : integer;
  EMail    : ShortString;
begin
  EMail := EMailIn;
  Result := True;
  cont := 0;
  if EMail <> '' then
    if (Pos('@', EMail)<>0) and (Pos('.', EMail)<>0) then    // existe @ .
    begin
      if (Pos('@', EMail)=1) or (Pos('@', EMail)= Length(EMail)) or (Pos('.', EMail)=1) or (Pos('.', EMail)= Length(EMail)) or (Pos(' ', EMail)<>0) then
        Result := False
      else                                   // @ seguido de . e vice-versa
        if (abs(Pos('@', EMail) - Pos('.', EMail)) = 1) then
          Result := False
        else
          begin
            for i := 1 to 40 do            // se existe Caracter Especial
              if Pos(CaraEsp[i], EMail)<>0 then
                Result := False;
            for i := 1 to length(EMail) do
            begin                                 // se existe apenas 1 @
              if EMail[i] = '@' then
                cont := cont + 1;                    // . seguidos de .
              if (EMail[i] = '.') and (EMail[i+1] = '.') then
                Result := false;
            end;
                                   // . no f, 2ou+ @, . no i, - no i, _ no i
            if (cont >=2) or ( EMail[length(EMail)]= '.' )
              or ( EMail[1]= '.' ) or ( EMail[1]= '_' )
              or ( EMail[1]= '-' )  then
                Result := false;
                                            // @ seguido de COM e vice-versa
            if (abs(Pos('@', EMail) - Pos('com', EMail)) = 1) then
              Result := False;
                                              // @ seguido de - e vice-versa
            if (abs(Pos('@', EMail) - Pos('-', EMail)) = 1) then
              Result := False;
                                              // @ seguido de _ e vice-versa
            {if (abs(Pos('@', EMail) - Pos('_', EMail)) = 1) then
              Result := False;}
          end;
    end
    else
      Result := False;
end;

//Comparar se duas Strings sao iguais
function ComparaStrings(st1, st2: String): boolean;
begin
   result := AnsiCompareText(st1, st2) = 0;
end;

//ConfigurarModeloImpressao
procedure setModeloImpressoraReport(out report: TRDprint);
begin
   {report.Impressora := Grafico;
   case (dtmData.getConfiguracao As TConfiguracao).getModeloImpressora of
      0:
      begin
         report.SetModelo('Bobina');
         report.Impressora := Bobina;
         report.PortaComunicacao := 'USB002';
         report.OpcoesPreview.Remalina := True;
      end;
      1:
      begin
         if not (dtmData.getConfiguracao As TConfiguracao).getUtilizarImpressoraPadraoWin Then
            report.SetPrinterbyName('EPSON');
         report.Impressora := Epson;
      end;
      2: report.Impressora := HP;
      3: report.Impressora := Rima;
      4:
      begin
         report.SetModelo('Gráfico');
         report.Impressora := Grafico;
      end;
      5: report.Impressora := Personalizado;
   end;}
end;

//Tipo meta produto
function tipoMetaToString(tipo: integer): String;
begin
   result := NULL_STRING;
   case tipo of
      0: result := 'UND';
      1: result := 'KG';
      2: result := 'TON';
   end;
end;

//Tipo meta vendedor
function tipoMetaVendedorToString(tipo: integer): String;
begin
   result := NULL_STRING;
   case tipo of
      0: result := '%';
      1: result := 'Q';
   end;
end;

//Formatar numero NF-e
function formatarNumeroNota(numero: double): string;
var
   chave: string;
begin
   chave := StrZero(TRUNC(numero), 9);
   result := 'No. ';
   result := result + Copy(chave, 1, 3) + '.';
   result := result + Copy(chave, 4, 3) + '.';
   result := result + Copy(chave, 7, 3);
end;

//Tratar mes da String do periodo
function  TratarMesPeriodo(periodo: String): String;
var
   mes: integer;
begin
   if strNumeros(Copy(periodo, 1, 2)) <> NULL_STRING then
   begin
      mes := StrToInt(strNumeros(Copy(periodo, 1, 2)));
      case mes of
         1: result := 'JAN' + Copy(periodo, 3, Length(periodo) -2);
         2: result := 'FEV' + Copy(periodo, 3, Length(periodo) -2);
         3: result := 'MAR' + Copy(periodo, 3, Length(periodo) -2);
         4: result := 'ABR' + Copy(periodo, 3, Length(periodo) -2);
         5: result := 'MAI' + Copy(periodo, 3, Length(periodo) -2);
         6: result := 'JUN' + Copy(periodo, 3, Length(periodo) -2);
         7: result := 'JUL' + Copy(periodo, 3, Length(periodo) -2);
         8: result := 'AGO' + Copy(periodo, 3, Length(periodo) -2);
         9: result := 'SET' + Copy(periodo, 3, Length(periodo) -2);
         10:result := 'OUT' + Copy(periodo, 3, Length(periodo) -2);
         11:result := 'NOV' + Copy(periodo, 3, Length(periodo) -2);
         12:result := 'DEZ' + Copy(periodo, 3, Length(periodo) -2);
      end;
   end else
      result := periodo;
end;

//verificar se existe uma palavra no texto
function ProcurarPalavraTexto(palavra, frase: String): boolean;
begin
   //result := AnsiContainsText(palavra, frase);
   result := procurarSubString(frase, palavra) <> 0;
end;

//Listar subDiretorios de uma pasta raiz
function ListarSubDiretorio(const sDirInicial: string): TStrings;
var
   xsrSearch: TSearchRec;
   xSearchPath: string;
   sltSub: TStrings;
   i: Integer;
   slt: TStrings;
begin
   slt := TStringList.Create;
   sltSub := TStringList.Create;

   try
      xSearchPath := sDirInicial;
      if FindFirst(xSearchPath + '*', faDirectory, xsrSearch) = 0 then
      repeat
         if ((xsrSearch.Attr and faDirectory) = faDirectory) and (xsrSearch.Name <> '.') and (xsrSearch.Name <> '..') then
         begin
           slt.Add(xSearchPath + xsrSearch.Name);
           sltSub.Add(xSearchPath + xsrSearch.Name);
         end;
      until (FindNext(xsrSearch) <> 0);
      //FindClose(xsrSearch);
      for i := 0 to sltSub.Count - 1 do
        ListarSubDiretorio(sltSub.Strings[i]);
   finally
     FreeAndNil(sltSub);
   end;
   result := slt;
end;

function booleanToChar(variavel: boolean): String;
begin
   if variavel then
      result := 'S'
   else
      result := 'N';
end;

function getIdComputador: String;
var
   u, c: array[0..127] of Char;
   sz: dword;
begin
   sz := SizeOf(u);
   GetUserName(u, sz);
   sz := SizeOf(c);
   GetComputerName(c, sz);
   //Label3.Caption := u;
   result := Trim(c);
end;

procedure arredondarComponente(Componente: TWinControl; const Radius: SmallInt);
var
  R : TRect;
  Rgn : HRGN;
begin
  with Componente do
  begin
    R := ClientRect;
    Rgn := CreateRoundRectRgn(R.Left, R.Top, R.Right, R.Bottom, Radius, Radius);
    Perform(EM_GETRECT, 0, lParam(@R));
    InflateRect(R, -5, -5);
    Perform(EM_SETRECTNP, 0, lParam(@R));
    SetWindowRgn(Handle, Rgn, True);
    Invalidate;
  end;
end;

function removerUltimoDigito(texto, digito: String): String;
begin
   if (Copy(texto, Length(texto), 1) = digito) then
      result := Copy(texto, 1, Length(texto) -1)
   else
      result := texto;
end;

function VerificarItemNoCombo(combo: TOrComboBox; informacao: String): boolean;
var
   i, pos: integer;
begin
   pos := NULL_INTEGER;
   for i := 0 to combo.Items.Count -1 do
   begin
      if (pos = NULL_INTEGER) then
      begin
         if (combo.Items[i] = informacao) then
         begin
            pos := i;
            break;
         end;
      end;
   end;
   result := (pos <> NULL_INTEGER);
end;

function StatusInterfaceToStr(StatusInterface: TStatusInterface): String;
begin
   if StatusInterface = stConsultar then
      result := 'CONSULTAR'
   else if StatusInterface = stIncluir then
      result := 'INCLUIR'
   else if StatusInterface = stExcluir then
      result := 'EXCLUIR'
   else if StatusInterface = stAlterar then
      result := 'ALTERAR'
   else if StatusInterface = stAcertar then
      result := 'ACERTAR'
   else
      result := 'SEM STATUS';
end;

function Confirmacao(texto: string): boolean;
begin
  Result := Application.MessageBox(PChar(texto),'Confirmação',MB_ICONQUESTION + MB_YESNO) = ID_YES;
end;

function PosToTipoDespesaReceitaConta(pos: integer): TTipoDespesaReceitaConta;
begin
   result := tdrIndefinido;
   case pos of
      0: result := tdrFixa;
      1: result := tdrVariavel;
      2: result := tdrInvestimento;
      3: result := tdrOperacional;
      4: result := tdrNaoOperacional;
   end;
end;

function TipoDespesaReceitaContaToPos(tipo: TTipoDespesaReceitaConta): integer;
begin
   result := POS_NAO_ENCONTRADA;
   if (tipo = tdrFixa) then
      result := 0
   else if (tipo = tdrVariavel) then
      result := 1
   else if (tipo = tdrInvestimento) then
      result := 2
   else if (tipo = tdrOperacional) then
      result := 3
   else if (tipo = tdrNaoOperacional) then
      result := 4;
end;

procedure processando(form: TForm);
begin
  with form do
  begin
    Screen.Cursor := crHourGlass;
    Refresh;
  end;
end;

procedure processoFinalizado(form: TForm);
begin
  with form do
  begin
    Screen.Cursor := crDefault;
    Refresh;
  end;
end;

procedure AbreForm(aClasseForm: TComponentClass; aForm: TForm);
begin
  Application.CreateForm(aClasseForm, aForm);
  try
    aForm.ShowModal;
  finally
    aForm.Free;
  end;
end;

//funcao que retorno o código ASCII dos caracteres
function AsciiToInt(Caracter: Char): Integer;
var
  i: Integer;
begin
  i := 32;
  while i < 255 do begin
    if Chr(i) = Caracter then
      Break;
    i := i + 1;
  end;
  Result := i;
end;

{ Esta funcao tem como objetivo criptografar uma string utilizando o
código ASCII de cada caracter e somando a esse código o valor da CHAVE}
function Criptografa(texto:string;chave:integer):String;
var
  cont:integer;
  retorno:string;
begin
  if (trim(texto)=EmptyStr) or (chave=0) then begin
    result:=texto;
  end else begin
    retorno:='';
    for cont:=1 to length(texto) do begin
      retorno:=retorno+chr(asciitoint(texto[cont])+chave);
    end;
    result:=retorno;
  end;
end;


{ Esta funcao é semelhante a funcao de
Criptografia mais com o objetivo de descriptografar a string }
function DesCriptografa(texto:string;chave:integer):String;
var
  cont:integer;
  retorno:string;
begin
  if (trim(texto)=EmptyStr) or (chave=0) then begin
    result:=texto;
  end else begin
    retorno:='';
    for cont:=1 to length(texto) do begin
      retorno:=retorno+chr(asciitoint(texto[cont])-chave);
    end;
    result:=retorno;
  end;
end;

function CalcularValorDesconto(valor, desconto: double):double;
begin
  result :=  (valor) - ((desconto * (valor))/100);
end;

procedure UsarArredondarView(Controle: TWinControl);
begin
  if Controle is TPanel then
  begin
    if (TPanel(Controle).Height < 165)  then
    begin
      TPanel(Controle).BorderStyle := bsNone;
      ArredondarMenoresView(Controle);
    end;
  end
  else if Controle is TEdit then
  begin
    TEdit(Controle).BorderStyle := bsNone;
    ArredondarMenoresView(Controle);
  end
  else if Controle is TOrEdit then
  begin
    TOrEdit(Controle).BorderStyle := bsNone;
    ArredondarMenoresView(Controle);
  end
  else if Controle is TOrCurrencyEdit then
  begin
    TOrCurrencyEdit(Controle).BorderStyle := bsNone;
    ArredondarMenoresView(Controle);
  end
  else if Controle is TOrMaskEdit then
  begin
    TOrMaskEdit(Controle).BorderStyle := bsNone;
    ArredondarMenoresView(Controle);
  end
  else if Controle is TRxSpinEdit then
  begin
    TRxSpinEdit(Controle).BorderStyle := bsNone;
    ArredondarMenoresView(Controle);
  end
  else if Controle is TOrMemo then
  begin
    TOrMemo(Controle).BorderStyle := bsNone;
    ArredondarMenoresView(Controle);
  end;
end;

//Biblioteca
function validar(doc: String; tipo: integer): boolean;
begin
  dtmData.getACBrValidador.Documento := doc;
  Case tipo of
    1  : dtmData.getACBrValidador.TipoDocto := docCPF;
    2  : dtmData.getACBrValidador.TipoDocto := docCNPJ;
    3  : dtmData.getACBrValidador.TipoDocto := docCAEPF;
    4  : dtmData.getACBrValidador.TipoDocto := docUF;
    5  : dtmData.getACBrValidador.TipoDocto := docInscEst;
    6  : dtmData.getACBrValidador.TipoDocto := docNumCheque;
    7  : dtmData.getACBrValidador.TipoDocto := docPIS;
    8  : dtmData.getACBrValidador.TipoDocto := docCEP;
    9  : dtmData.getACBrValidador.TipoDocto := docCartaoCredito;
    10 : dtmData.getACBrValidador.TipoDocto := docSuframa;
    11 : dtmData.getACBrValidador.TipoDocto := docGTIN;
    12 : dtmData.getACBrValidador.TipoDocto := docRenavam;
    13 : dtmData.getACBrValidador.TipoDocto := docEmail;
    14 : dtmData.getACBrValidador.TipoDocto := docCNH;
    15 : dtmData.getACBrValidador.TipoDocto := docPrefixoGTIN;
    16 : dtmData.getACBrValidador.TipoDocto := docPlacaMercosul;
    17 : dtmData.getACBrValidador.TipoDocto := docCNS;
  end;
  result := dtmData.getACBrValidador.Validar;

end;

//Biblioteca
function ValidarTexto(texto: String): Boolean;
const
  CaracteresEspeciais = '!@#$%^&*()_+{}[]|\:;"<>,.?/~`';
var
  i: Integer;
begin
  Result := true;

  // Verifica cada caractere no texto
  for i := 1 to Length(texto) do
  begin
    if  (texto[i] in ['A'..'Z', 'a'..'z']) then
    begin
      Result := True; // Se um caractere for texto, define como True e sai do loop
      Break;
    end
    else
    Result := False;
  end;
end;


procedure ArredondarMenoresView(Control: TWinControl);
var
  R: TRect;
  Rgn: HRGN;
begin
  R := Control.ClientRect;
  Rgn := CreateRoundRectRgn(R.Left, R.Top, R.Right, R.Bottom, 5, 5);
  SetWindowRgn(Control.Handle, Rgn, True);
  InvalidateRect(Control.Handle, nil, True);
end;

function MostrarIdOuTexto(texto: String): Integer;
begin
  if ValidarTexto(texto) then
    Result := 0
  else
    Result := 1;
end;

// tem que ser na classe biblioteca
procedure ArredondarMaioresView(Control: TWinControl);
var
  R: TRect;
  Rgn: HRGN;
begin
  with Control do
  begin
   R := ClientRect;
   rgn := CreateRoundRectRgn(R.Left, R.Top, R.Right, R.Bottom, 15, 15);
   Perform(EM_GETRECT, 0, lParam(@r));
   InflateRect(r, - 5, - 5);
   Perform(EM_SETRECTNP, 0, lParam(@r));
   SetWindowRgn(Handle, rgn, True);
   Invalidate;
  end;
end;

procedure TratarCamposNegativos(Sender: TObject);
var
  lValor: Double;
  CurrencyEdit: TOrCurrencyEdit;
begin
  // Certifique-se de que o Sender seja um TOrCurrencyEdit
  if Sender is TOrCurrencyEdit then
  begin
    CurrencyEdit := Sender as TOrCurrencyEdit;
    // Tente converter o valor do TOrCurrencyEdit para um Double
    if TryStrToFloat(CurrencyEdit.Text, lValor) then
    begin
      if lValor < 0 then
      begin
        Application.MessageBox(MSG_VALOR_NEGATIVO, MT_ALERTA, MB_OK + MB_ICONWARNING);
        lValor := Abs(lValor);  // Corrige para valor positivo
        CurrencyEdit.Text := FloatToStr(lValor);  // Atualiza o texto do TOrCurrencyEdit
      end;
    end;
  end;
end;

//Mensagem Simples sem botao
procedure MostrarMensagem(form: TForm; mensagem: String; tipo: TTipoMensagem; URL: String = '');
var
  frmMensagem: TfrmMensagem;
begin
  frmMensagem := TfrmMensagem.Create(form);
  frmMensagem.setMensagem(mensagem, tipo, URL);
  frmMensagem.ShowModal;
  frmMensagem.Release;
end;

function DiasEmAtraso(de, ate: TDateTime): Integer;
begin
  Result := Trunc(DaysBetween(de, ate));
  if ate < de then
    Result := -Result;
end;

procedure AtualizarImagem(const AImagemNome: string; spd: TSpeedButton);
var
  CaminhoImagem: string;
begin
  CaminhoImagem := GetApplicationPath + 'imagem\' + AImagemNome;

  if FileExists(CaminhoImagem) then
    spd.Glyph.LoadFromFile(CaminhoImagem)
  else
    ShowMessage('Imagem não encontrada: ' + CaminhoImagem);
end;


function AlternarCorZebrada: TColor;
begin
  if LinhaImpar then
    Result := clWhite // Cor da linha ímpar
  else
    Result := $00F7F7F7; // Cor da linha par (cinza claro)

  LinhaImpar := not LinhaImpar; // Alterna entre ímpar e par
end;

procedure ResetarCorZebrada;
begin
  LinhaImpar := True;
end;

function IdentificarTipo(const Valor: string): string;
var
  IntValue: Integer;
  CurrValue: Currency;
begin
  if TryStrToInt(Valor, IntValue) then
    Result := 'INTEGER'
  else if TryStrToCurr(Valor, CurrValue) then
    Result := 'CURRENCY'
  else if ((Length(valor) <> Length(strNumeros(valor))) and (Length(strNumeros(valor)) > 0)) then
    Result := 'REFERENCIA'
  else if (MatchText(UpperCase(Valor), ['PP','P','M','G','GG','XG','XXG','EXG','U','UNICO','G1','G2','G3'])) then
    Result := 'TAMANHO'
  else
    Result := 'LIVRE';
end;

function MascararSenha(password: String): String;
begin
  result := StringOfChar('*', Length(password));
end;

function TemDadosGrid(grid: TOrStringGrid): boolean;
begin
  result := (grid.RowCount > 0) and (grid.Cells[0, grid.Row] <> NULL_STRING);
end;

function BuscarCep(cep: String): boolean;
begin
  result := false;
  try
     result := dtmData.getACBrCEP.BuscarPorCEP(cep) > 0;
  except
    raise ;
  end;
end;

function posItemCombo(combo: TOrComboBox; valor: String): integer;
var
  Index: Integer;
  ItemProcurado: string;
begin
  Index := combo.Items.IndexOf(valor);

  if Index <> POS_NAO_ENCONTRADA then
  begin
    combo.ItemIndex := Index; // Seleciona o item encontrado
    result := Index;
  end
  else
    result := POS_NAO_ENCONTRADA;
end;

function ValidateCST(CSTCode: string): TCstType;
var
  Code: string;
  I, tamanho: Integer;
begin
  tamanho := Length(CSTCode);
  if (tamanho > 2) then
    CSTCode := Copy(CSTCode, 1, 2);

  Result := ctInvalid;
  Code := Trim(CSTCode);

  // Verifica se está na lista de CST ICMS
  for I := Low(CST_ICMS) to High(CST_ICMS) do
    if Code = CST_ICMS[I] then
      Exit(ctICMS);

  // Verifica se está na lista de CST IPI
  for I := Low(CST_IPI) to High(CST_IPI) do
    if Code = CST_IPI[I] then
      Exit(ctIPI);

  // Verifica se está na lista de CST PIS/COFINS
  for I := Low(CST_PIS_COFINS) to High(CST_PIS_COFINS) do
    if Code = CST_PIS_COFINS[I] then
      Exit(ctPIS); // Como CST de PIS e COFINS são iguais, pode-se tratar ambos

  // Se não encontrou, retorna inválido
  Result := ctInvalid;
end;

function ValidarCST(CST : string): boolean;
begin
  result := ValidateCST(CST) <> ctInvalid
end;

function ValidarPorcentagem(const Value: string): Boolean;
var
  Percentage: Double;
begin
  Result := False;

  // Tenta converter a string para número
  if TryStrToFloat(Trim(Value), Percentage) then
  begin
    // Verifica se está no intervalo permitido
    if (Percentage >= 0) and (Percentage <= 100) then
      Result := True;
  end;
end;

function ArredondarPara4Casas(Valor: Double): Double;
begin
  // Arredonda para 4 casas decimais
  Result := RoundTo(Valor, -3);
end;

function TruncarPara2Casas(Valor: Double): Double;
begin
  // Trunca para 2 casas decimais (sem arredondar)
  Result := Trunc(Valor * 100) / 100;
end;


function formatarValorNfe(Valor: Double): Double;
begin
  result := TruncarPara2Casas(ArredondarPara4Casas(valor));
end;


procedure PreencherComboMesesAnos(cmb: TComboBox);
const
  INTERVALO_ANOS = 5;
var
  Ano, Mes: Integer;
  Data: TDate;
  NomeMes: string;
begin
  cmb.Items.BeginUpdate;
  try
    cmb.Items.Clear;
    for Ano := YearOf(Date) - INTERVALO_ANOS to YearOf(Date) + INTERVALO_ANOS do
    begin
      for Mes := 1 to 12 do
      begin
        // Obtém o nome do mês completo (por extenso)
        NomeMes := UpperCase(FormatDateTime('mmmm', EncodeDate(Ano, Mes, 1)));
        // Adiciona ao ComboBox no formato MES/ANO
        cmb.Items.Add(NomeMes + '/' + IntToStr(Ano));
      end;
    end;
  finally
    cmb.Items.EndUpdate;
  end;
end;

function QuebrarTexto(const Texto: string; TamanhoLinha: Integer): string;
var
  i: Integer;
begin
  Result := '';
  i := 1;
  while i <= Length(Texto) do
  begin
    Result := Result + Copy(Texto, i, TamanhoLinha) + sLineBreak;
    Inc(i, TamanhoLinha);
  end;
end;

function GetExeVersion: string;
var
  VerInfoSize, VerHandle: DWORD;
  VerInfo: Pointer;
  VerValueSize: UINT;
  VerValue: PVSFixedFileInfo;
  FileName: String;
begin
  Result := '';
  FileName := Application.ExeName;
  // Obtém o tamanho das informações de versão
  VerInfoSize := GetFileVersionInfoSize(PChar(FileName), VerHandle);
  if VerInfoSize = 0 then
    Exit;

  // Aloca memória para as informações de versão
  GetMem(VerInfo, VerInfoSize);

  try
    // Obtém as informações de versão
    if GetFileVersionInfo(PChar(FileName), VerHandle, VerInfoSize, VerInfo) then
    begin
      // Obtém as informações do arquivo
      if VerQueryValue(VerInfo, '\', Pointer(VerValue), VerValueSize) then
      begin
        // Formata a versão do arquivo
        Result := Format('%d.%d.%d.%d', [
          HiWord(VerValue^.dwFileVersionMS), LoWord(VerValue^.dwFileVersionMS),
          HiWord(VerValue^.dwFileVersionLS), LoWord(VerValue^.dwFileVersionLS)
        ]);
      end;
    end;
  finally
    FreeMem(VerInfo);
  end;
end;

procedure AtualizarCoresReceberPagar(FImagemAtual: Integer; lblReceber, lblPagar: TLabel);
begin
  case FImagemAtual of
    1:
    begin
      lblReceber.Font.Color := clBlue;
      lblPagar.Font.Color := clBlack;
    end;
    2:
    begin
      lblPagar.Font.Color := clRed;
      lblReceber.Font.Color := clBlack;
    end;
  end;
end;

//Selecionar tipo do filtro mercadoria
function escolherFiltroMercadoria(combo: TOrComboBox; descricao: String): integer;
var
  tipo: String;
begin
  if (Trim(descricao) <> NULL_STRING) then
    tipo := IdentificarTipo(descricao)
  else
    tipo := NULL_STRING;

  if (tipo = 'LIVRE') then
    result := 0
  else if (tipo = 'INTEGER') then
    result := 1
  else if ((tipo = 'CURRENCY') and (combo.Items.Count > 1)) then
    result := 2
  else if (tipo = 'REFERENCIA') and (combo.Items.Count > 2) then
    result := 3
  else if (tipo = 'TAMANHO') and (combo.Items.Count > 3) then
    result := 4
  else
    result := 0;
end;

end.

